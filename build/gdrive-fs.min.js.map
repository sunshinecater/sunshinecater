{"version":3,"sources":["node_modules/debug/node_modules/ms/index.js","node_modules/debug/src/common.js","node_modules/process/browser.js","node_modules/debug/src/browser.js","lib/gdfs-event.js","lib/gdfs-path.js","lib/gdfs.js","lib/gdfs-ui.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","useColors","window","type","__nwjs","navigator","userAgent","toLowerCase","match","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","parseInt","RegExp","$1","formatArgs","namespace","humanize","diff","c","color","splice","index","lastC","replace","log","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","localstorage","localStorage","colors","require","formatters","j","v","JSON","stringify","message","debug","GdfsEvent","target","eventName","_target","_eventName","listen","handler","constructor","addEventListener","event","fire","extraData","Event","key","Object","keys","dispatchEvent","GdfsPath","pathname","_lastSlash","_absolute","_paths","undefined","parse","getPathPart","toString","paths","elements","join","getFilename","pop","map","item","unshift","merge","p","reduce","pathA","pathB","a","b","isAbsolute","joined","split_path","escaped","element","chars","split","lastSlash","absolute","shift","replacement","acc","next","isArray","last","isDirSpec","rootSpec","dirSpec","Gdfs","_oncwdupdate","_currentPath","id","createClient","signInStatusChangeEvent","loadApi","clientId","clientSecret","script","createElement","setAttribute","Promise","resolve","reject","onload","gapi","client","init","discoveryDocs","scope","auth2","getAuthInstance","isSignedIn","readyState","onerror","URIError","src","body","appendChild","mimeTypeFolder","get","signIn","signOut","getFileList","response","drive","files","list","queryParameters","result","findFolderByName","parentFolderId","folderName","folders","params","q","file","pageToken","nextPageToken","err","stack","findFileByName","fileName","getFileResource","parameters","isFolder","mimeType","downloadFile","fileId","acknowledgeAbuse","requestWithAuth","alt","createFile","folderId","filename","parents","updateFile","data","uploadType","method","endpoint","queryParams","headers","xhr","XMLHttpRequest","open","createUrl","forEach","setRequestHeader","getAccessToken","responseText","statusText","ontimeout","send","accessToken","currentUser","getAuthResponse","access_token","filter","value","encodeURI","getActualRootFolderId","res","fields","onCwdUpdate","prev","fireCwdUpdate","getCurrentFolderId","slice","getCurrentPath","path","setCurrentPath","isDirectory","getPaths","parent","children","child","getFileOfPath","directory","next_cwd","chdirById","currentFolderId","root","searchId","toAbsolutePath","readdir","options","absPath","parentFolder","readAll","pageSize","readFiles","stat","readFile","webContentLink","mkdir","rmdir","dires","delete","unlink","writeFile","GdfsUi","opt","_element","_gdfs","_pageSize","_trashed","_pageToken","_files","_opt","onFileListChange","onCurrentDirChange","_fileListChangeEvent","_currentDirChangeEvent","reload","onSignedInStatusChange","status","isPageCompleted","getFiles","begin","end","readDir","andConditionsOfQuerySearchClauses","uploadFile","reader","FileReader","readAsArrayBuffer","fileIds","Ui","Path","Function"],"mappings":"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","file":"gdrive-fs.min.js","sourceRoot":"..","sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsEvent\");\r\n/**\r\n * Event class\r\n * @constructor\r\n * @param {HTMLElement} target An element that dispatch\r\n * @param {string} eventName An event name\r\n */\r\nfunction GdfsEvent(target, eventName) {\r\n    this._target = target;\r\n    this._eventName = eventName;\r\n}\r\n\r\n/**\r\n * Listen this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.listen = function(handler) {\r\n    debug(`GdfsEvent.listen: ${this._eventName}=>${handler.constructor.name}`);\r\n    if(handler.constructor.name === \"AsyncFunction\") {\r\n        this._target.addEventListener(\r\n            this._eventName, async event => await handler(event));\r\n    } else {\r\n        this._target.addEventListener(\r\n            this._eventName, handler);\r\n    }\r\n};\r\n\r\n/**\r\n * Fire this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.fire = function(extraData = {}) {\r\n    const event = new Event(this._eventName);\r\n    for(const key of Object.keys(extraData)) {\r\n        event[key] = extraData[key];\r\n    }\r\n    debug(\r\n        `GdfsEvent.fire: ${this._eventName}`,\r\n        `extraData: ${JSON.stringify(extraData)}`);\r\n    this._target.dispatchEvent(event);\r\n};\r\n\r\nmodule.exports = GdfsEvent;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsPath\");\r\ndebug(\"loading\");\r\n\r\n/**\r\n * Gdfs Path class.\r\n * @constructor\r\n * @param {string|undefined} pathname initial path.\r\n */\r\nfunction GdfsPath(pathname) {\r\n    this._lastSlash = true;\r\n    this._absolute = true;\r\n    this._paths = [];\r\n    if(pathname != undefined) {\r\n        this.parse(pathname);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Get a part of path.\r\n * @returns {GdfsPath} A path object including only path.\r\n */\r\nGdfsPath.prototype.getPathPart = function() {\r\n    if(this._lastSlash) {\r\n        return new GdfsPath(this.toString());\r\n    }\r\n    const paths = this.elements();\r\n    paths.splice(-1, 1, \"\");\r\n    debug(`getPathPart: paths: ${JSON.stringify(paths)}`);\r\n    return new GdfsPath(paths.join(\"/\"));\r\n};\r\n\r\n/**\r\n * Get filename part of path.\r\n * @returns {string} A filename.\r\n */\r\nGdfsPath.prototype.getFilename = function() {\r\n    return this.elements().pop();\r\n};\r\n\r\n/**\r\n * Get paths elements.\r\n * @returns {Array<string>} the elements.\r\n */\r\nGdfsPath.prototype.elements = function() {\r\n    const elements = this._paths.map(item => item);\r\n    if(this._absolute) {\r\n        elements.unshift(\"\");\r\n    }\r\n    if(this._lastSlash) {\r\n        elements.push(\"\");\r\n    }\r\n    return elements;\r\n};\r\n\r\n/**\r\n * Create a new path object with joining the two paths.\r\n * \r\n * @param {Array<GdfsPath>} paths The paths to join.\r\n * @returns {GdfsPath} The path that was joined.\r\n */\r\nGdfsPath.merge = (...paths) => {\r\n    debug(`Gdfs.merge: ${paths.map(p=>p.toString()).join(\" | \")}`);\r\n    return paths.reduce( (pathA, pathB, index) => {\r\n        debug(`Gdfs.merge: Reducing #${index}`);\r\n        debug(`Gdfs.merge: pathA: ${pathA.toString()}`);\r\n        debug(`Gdfs.merge: pathB: ${pathB.toString()}`);\r\n        if(typeof(pathA) === \"string\") {\r\n            pathA = new GdfsPath(pathA);\r\n        }\r\n        if(typeof(pathB) === \"string\") {\r\n            pathB = new GdfsPath(pathB);\r\n        }\r\n        const a = pathA.toString();\r\n        const b = pathB.toString();\r\n        if(pathB.isAbsolute()) {\r\n            debug(`returns ${b}`);\r\n            return new GdfsPath(b);\r\n        }\r\n        const joined = new GdfsPath([a, b].join(\"/\"));\r\n        debug(`Gdfs.merge: returns ${joined.toString()}`);\r\n        return joined;\r\n    });\r\n};\r\n\r\nconst split_path = pathname => {\r\n    const paths = [];\r\n    let escaped = false;\r\n    let i = 0;\r\n    let element = \"\";\r\n    let chars = pathname.split(\"\");\r\n    while(i < chars.length) {\r\n        const c = chars[i];\r\n        if(escaped) {\r\n            element += c;\r\n            escaped = false;\r\n        } else if(c === \"\\\\\"){\r\n            escaped = true;\r\n        } else if(c === \"/\") {\r\n            paths.push(element);\r\n            element = \"\";\r\n        } else {\r\n            element += c;\r\n        }\r\n        i++;\r\n    }\r\n    paths.push(element);\r\n    if(escaped) {\r\n        throw new Error(`Invalid pathname ${pathname}`);\r\n    }\r\n    if(paths.length == 0) {\r\n        throw new Error(\"Invalid pathname. It should not be empty.\");\r\n    }\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Set a path repersented by a string.\r\n * @param {string} pathname A path name to parse\r\n * @return {undefined}\r\n */\r\nGdfsPath.prototype.parse = function(pathname) {\r\n    let paths = split_path(pathname.replace(/\\/+/g, \"/\"));\r\n    debug(`parse ${JSON.stringify(pathname)} => ${JSON.stringify(paths)}`);\r\n    const lastSlash = (paths[paths.length - 1] === \"\");\r\n    const absolute = (paths[0] === \"\");\r\n    if(lastSlash) {\r\n        paths.pop();\r\n    }\r\n    if(absolute) {\r\n        paths.shift();\r\n    }\r\n    this._lastSlash = !!lastSlash;\r\n    this._absolute = !!absolute;\r\n    for(;;) {\r\n        let replacement = false;\r\n        if(paths.length >= 2) {\r\n            paths = paths.reduce( (acc, next) => {\r\n                if(!Array.isArray(acc)) {\r\n                    acc = [acc];\r\n                }\r\n                const last = acc[acc.length - 1];\r\n                if(last !== \"..\" && next === \"..\") {\r\n                    acc.pop();\r\n                    replacement = true;\r\n                } else if(last !== \".\" && next === \".\") {\r\n                    replacement = true;\r\n                } else {\r\n                    acc.push(next);\r\n                }\r\n                return acc;\r\n            });\r\n        }\r\n        if(!replacement) {\r\n            this._paths = paths;\r\n            debug(`this._paths:${JSON.stringify(this._paths)}`);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns if this represents an absolute path.\r\n * @returns {Boolean} True if this represents an absolute path, otherwise false.\r\n */\r\nGdfsPath.prototype.isAbsolute = function() {\r\n    return this._absolute;\r\n};\r\n\r\n/**\r\n * Returns if this represents a directory.\r\n * @returns {Boolean} True if this represents a directory, otherwise false.\r\n */\r\nGdfsPath.prototype.isDirSpec = function() {\r\n    return this._lastSlash;\r\n};\r\n\r\n/**\r\n * Returns a path represented by string.\r\n * @returns {string} The path that this is representing.\r\n */\r\nGdfsPath.prototype.toString = function() {\r\n    if(this._paths.length === 0) {\r\n        return \"/\";\r\n    }\r\n    const rootSpec = this._absolute ? \"/\" : \"\";\r\n    const dirSpec = this._lastSlash ? \"/\" : \"\";\r\n    const pathname = `${rootSpec}${this._paths.join(\"/\")}${dirSpec}`;\r\n    return pathname;\r\n};\r\n\r\nmodule.exports = GdfsPath;\r\n","/*global gapi:false*/\r\n\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs\");\r\ndebug(\"loading\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\nconst GdfsPath = require(\"./gdfs-path.js\");\r\n\r\n/**\r\n * Gdfs class is an interface for the Google Drive API v3.\r\n *\r\n * The instance manages a current working directory(CWD) and offers methods\r\n * to operate files and folders on the Google Drive by its pathname.\r\n *\r\n * Before creating an instance, the APIs must be loaded by the class method\r\n * [`loadApi`](#.loadApi) with a ClientId and ApiKey.\r\n * These had to be created in a project of Google devloper Console.\r\n *\r\n * And to operates files, user must sign-in with the Google account.\r\n * See [signIn](#.signIn) and [signOut](#.signOut).\r\n *\r\n * Instance's CWD is initialized to the root on constructor. It can be changed\r\n * by [chdir](#chdir) method. When it is changed, the 'oncwdupdate' callback\r\n * is fired. To know where the CWD is, The [cwd](#cwd) method is available.\r\n *\r\n * @constructor\r\n */\r\nfunction Gdfs() {\r\n    this._oncwdupdate = null;\r\n    this._currentPath = [{ id: \"root\", name: \"\", }];\r\n}\r\n\r\n/**\r\n * Create Gdfs client.\r\n * @returns {Gdfs} The google drive interface that has a current directory.\r\n */\r\nGdfs.createClient = () => {\r\n    return new Gdfs();\r\n};\r\n\r\n/**\r\n * signInStatusChangeEvent\r\n * @type {GdfsEvent}\r\n */\r\nGdfs.signInStatusChangeEvent = new GdfsEvent(\r\n    window, \"gdfs-signin-status-change\");\r\n\r\n/**\r\n * Load Google Drive APIs and initialize its client object.\r\n *\r\n * The loaded all APIs are accessible with a global `gapi` object.\r\n * But it is wrapped by this class so the users should not use it directly.\r\n *\r\n * @param {string} clientId A clientId from the Developer console.\r\n * @param {string} clientSecret An clientSecret from the Developer console.\r\n * @returns {Promise} A promise that will be resolved when the loading completed.\r\n */\r\nGdfs.loadApi = (clientId, clientSecret) => {\r\n    debug(\"Start of Gdfs.loadApi\");\r\n    const script = document.createElement(\"SCRIPT\");\r\n    script.setAttribute(\"async\", \"async\");\r\n    script.setAttribute(\"src\", \"https://apis.google.com/js/api.js\");\r\n    const p = new Promise( (resolve, reject) => {\r\n        script.addEventListener(\"load\", () => {\r\n            script.onload = () => {};\r\n            gapi.load(\"client:auth2\", async () => {\r\n                debug(\"initialize gapi.client\");\r\n\r\n                if(typeof(clientId) === \"object\" && clientSecret == null &&\r\n                    \"clientId\" in clientId && \"clientSecret\" in clientId &&\r\n                    \"discoveryDocs\" in clientId && \"scope\" in clientId)\r\n                {\r\n                    await gapi.client.init(clientId);\r\n                } else {\r\n                    await gapi.client.init({\r\n                        clientId, clientSecret,\r\n                        discoveryDocs: [\r\n                            \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\r\n                        ],\r\n                        scope: [\r\n                            \"https://www.googleapis.com/auth/drive\",\r\n                            \"https://www.googleapis.com/auth/drive.appdata\",\r\n                            \"https://www.googleapis.com/auth/drive.file\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.photos.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.readonly\",\r\n                        ].join(\" \"),\r\n                    });\r\n                }\r\n                gapi.auth2.getAuthInstance().isSignedIn.listen( () => {\r\n                    debug(\"the signed-in-status changed\");\r\n                    Gdfs.signInStatusChangeEvent.fire();\r\n                });\r\n                Gdfs.signInStatusChangeEvent.fire();\r\n                debug(`Gdfs.loadApi SignedIn: ${Gdfs.isSignedIn()}`);\r\n                debug(\"Gdfs.loadApi is resolved\");\r\n                resolve();\r\n            });\r\n        });\r\n        script.addEventListener(\"readystatechange\", () => {\r\n            debug(`readystatechange ${script.readyState}`);\r\n            if(script.readyState === \"complete\") {\r\n                script.onload();\r\n            }\r\n        });\r\n        script.onerror = event => {\r\n            debug(\"Gdfs.loadApi is rejected\");\r\n            reject(new URIError(\r\n                `The script ${event.target.src} is not accessible.`));\r\n        };\r\n        document.body.appendChild(script);\r\n    });\r\n    debug(\"End of Gdfs.loadApi\");\r\n    return p;\r\n};\r\n\r\n/**\r\n * A mime type of the Google Drive's folder.\r\n * @type {string}\r\n */\r\nGdfs.mimeTypeFolder = \"application/vnd.google-apps.folder\";\r\n\r\n/**\r\n * Check if gapi was signed in.\r\n * @returns {boolean} true if gapi is signed in, otherwise false.\r\n */\r\nGdfs.isSignedIn = () => {\r\n    return gapi.auth2.getAuthInstance().isSignedIn.get();\r\n};\r\n\r\n/**\r\n * Sign in to Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signIn = async () => {\r\n    return await gapi.auth2.getAuthInstance().signIn();\r\n};\r\n\r\n/**\r\n * Sign out from the Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signOut = async () => {\r\n    return await gapi.auth2.getAuthInstance().signOut();\r\n};\r\n\r\n/**\r\n * Get file list.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileList = async (queryParameters) => {\r\n    const response = await gapi.client.drive.files.list(queryParameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Find a folder by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} folderName A folder name to find\r\n * @returns {Array<object>} A folder list that found.\r\n */\r\nGdfs.findFolderByName = async (parentFolderId, folderName) => {\r\n    debug(\"No tests pass: Gdfs.findFolderByName\");\r\n\r\n    const folders = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${folderName}'`,\r\n        `mimeType = '${Gdfs.mimeTypeFolder}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`${JSON.stringify(params)}`);\r\n    try {\r\n        do {\r\n            const result = await Gdfs.getFileList(params);\r\n            debug(`${JSON.stringify(result)}`);\r\n            for(const file of result.files) {\r\n                folders.push(file);\r\n            }\r\n            params.pageToken = result.nextPageToken;\r\n        } while(params.pageToken != null);\r\n    } catch(err) {\r\n        debug(err.stack);\r\n    }\r\n\r\n    return folders;\r\n};\r\n\r\n/**\r\n * Find a file by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} fileName A file name to find\r\n * @returns {Promise<Array<object> >} A folder list that found.\r\n */\r\nGdfs.findFileByName = async (parentFolderId, fileName) => {\r\n    debug(\"No tests pass: Gdfs.findFileByName\");\r\n\r\n    const files = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${fileName}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`findFileByName: params: ${JSON.stringify(params, null, \"  \")}`);\r\n    do {\r\n        const result = await Gdfs.getFileList(params);\r\n        for(const file of result.files) {\r\n            debug(`findFileByName: found file: ${JSON.stringify(file)}`);\r\n            files.push(file);\r\n        }\r\n        debug(`findFileByName: result.nextPageToken: ${result.nextPageToken}`);\r\n        params.pageToken = result.nextPageToken;\r\n    } while(params.pageToken != null);\r\n\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileResource = async (parameters) => {\r\n    const response = await gapi.client.drive.files.get(parameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Check if the file is a folder.\r\n * @param {object} file The file object provided from the result\r\n * of `getFileList` method.\r\n * @returns {boolean} The file is a folder or not.\r\n */\r\nGdfs.isFolder = (file) => {\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Get a file content as text from Google Drive.\r\n * Even if the file is not a text actually, it could be converted\r\n * to ArrayBuffer, Blob or JSON to use by Web App.\r\n * @param {string} fileId The file id to download.\r\n * @param {boolean|null} acknowledgeAbuse A user acknowledgment\r\n * status for the potential to abuse. This parameter is optional.\r\n * default value is false.\r\n * @returns {Promise<string>} A downloaded content as text.\r\n */\r\nGdfs.downloadFile = (fileId, acknowledgeAbuse) => {\r\n    return requestWithAuth(\"GET\",\r\n        \"https://www.googleapis.com/drive/v3/files/\"+fileId,\r\n        { alt: \"media\", acknowledgeAbuse : acknowledgeAbuse });\r\n};\r\n\r\n/**\r\n * Create a new file's resource.\r\n * @param {string} folderId The folder id where the file is created.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The mime type for the new file.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.createFile = async (folderId, filename, mimeType) => {\r\n    const response = await requestWithAuth(\"POST\",\r\n        \"https://www.googleapis.com/drive/v3/files\", {},\r\n        { \"Content-Type\": \"application/json\", },\r\n        JSON.stringify({\r\n            name: filename,\r\n            mimeType: mimeType,\r\n            parents: [folderId],\r\n        }));\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * Upload a file content to update a existing file.\r\n * @param {string} fileId The file id to update.\r\n * @param {string} mimeType The content type of the file.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.updateFile = async (fileId, mimeType, data) => {\r\n    const response = await requestWithAuth(\"PATCH\",\r\n        \"https://www.googleapis.com/upload/drive/v3/files/\"+fileId,\r\n        { uploadType: \"media\" },\r\n        { \"Content-Type\": mimeType },\r\n        data);\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * @param {string} method The request method.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object} queryParams The query parameters.\r\n * @param {object} headers The request headers.\r\n * @param {any} body The request body.\r\n * @returns {Promise<object>} The response of the request.\r\n */\r\nconst requestWithAuth = (method, endpoint, queryParams, headers, body) => {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open(method, createUrl(endpoint, queryParams), true);\r\n    headers = headers || {};\r\n    Object.keys(headers).forEach( name => {\r\n        xhr.setRequestHeader(name, headers[name]);\r\n    });\r\n    xhr.setRequestHeader(\"Authorization\",\r\n        \"Bearer \" + getAccessToken());\r\n    xhr.timeout = 30000;\r\n    return new Promise( (resolve, reject) => {\r\n        xhr.onload = () => { resolve(xhr.responseText); };\r\n        xhr.onerror = () => { reject(new Error(xhr.statusText)); };\r\n        xhr.ontimeout = () => { reject(new Error(\"request timeout\")); };\r\n        xhr.send(body);\r\n    });\r\n};\r\n\r\n/**\r\n * Get access-token on current session.\r\n * @returns {string} The access token.\r\n */\r\nconst getAccessToken = () => {\r\n    const googleUser = gapi.auth2.getAuthInstance().currentUser.get();\r\n    const authResponse = googleUser.getAuthResponse(true);\r\n    const accessToken = authResponse.access_token;\r\n    return accessToken;\r\n};\r\n\r\n/**\r\n * Create URI including query parameters.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object|null} params The query parameters.\r\n * @returns {string} The URI.\r\n */\r\nconst createUrl = (endpoint, params) => {\r\n    if(params == null) {\r\n        return endpoint;\r\n    }\r\n    let keys = Object.keys(params).filter(\r\n        key => (key !== \"\"));\r\n    if(keys.length == 0) {\r\n        return endpoint;\r\n    }\r\n    let queryString = keys.map( key => {\r\n        let value = params[key];\r\n        return (value == null ? null : `${key}=${encodeURI(value)}`);\r\n    }).join(\"&\");\r\n    return `${endpoint}?${queryString}`;\r\n};\r\n\r\n/**\r\n * Get actual root folder id.\r\n * @async\r\n * @return {Promise<string>} The root folder's id\r\n */\r\nGdfs.getActualRootFolderId = async () => {\r\n    const res = await Gdfs.getFileResource({ fileId: \"root\", fields: \"id\" });\r\n    debug(`getActualRootFolderId: res ${JSON.stringify(res, null, \"  \")}`);\r\n    return res.id;\r\n};\r\n\r\n/**\r\n * Set oncwdchage callback hander.\r\n * @param {FUnction|AsyncFunction} handler a function to be invoked when\r\n *      the current directory is changed.\r\n * @returns {undefined|Function} the previous handler will be returned.\r\n */\r\nGdfs.prototype.onCwdUpdate = function(handler) {\r\n    const prev = this._oncwdupdate;\r\n    if(handler != null) {\r\n        this._oncwdupdate = handler;\r\n    }\r\n    return prev;\r\n};\r\n\r\n/**\r\n * Fire cwdUpdate.\r\n * @returns {Promise} what the handler returns.\r\n */\r\nGdfs.prototype.fireCwdUpdate = async function() {\r\n    if(this._oncwdupdate) {\r\n        try {\r\n            const result = this._oncwdupdate();\r\n            if(result != null) {\r\n                if(result.constructor === Promise) {\r\n                    return await result;\r\n                }\r\n                return result;\r\n            }\r\n        } catch (err) {\r\n            debug(err.stack);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Get current folder id.\r\n * @returns {string} The folder id that the instance is.\r\n */\r\nGdfs.prototype.getCurrentFolderId = function() {\r\n    return this._currentPath.slice(-1)[0].id;\r\n};\r\n\r\n/**\r\n * Get current working directory as path object.\r\n * @returns {GdfsPath} the current working directory.\r\n */\r\nGdfs.prototype.getCurrentPath = function() {\r\n    const path = this._currentPath.map( path => `${path.name}/`).join(\"\");\r\n    const cwd = new GdfsPath(path);\r\n    debug(`getCurrentPath: ${cwd.toString()}`);\r\n    return cwd;\r\n};\r\n\r\n/**\r\n * Set current working directory with path object.\r\n * @async\r\n * @param {GdfsPath} path the new current working directory.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.setCurrentPath = async function(path) {\r\n    debug(\"No tests pass: Gdfs#setCurrentPath\");\r\n    debug(`setCurrentPath(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(`The path must be absolute. ${path}`);\r\n        return false;\r\n    }\r\n    if(!(await this.isDirectory(path))) {\r\n        debug(`${path} is not a directory`);\r\n        return false;\r\n    }\r\n    this._currentPath = await this.getPaths(path);\r\n    await this.fireCwdUpdate();\r\n    return true;\r\n};\r\n\r\n/**\r\n * Get an array of path element from root directory.\r\n * @async\r\n * @param {GdfsPath} path path object.\r\n * @returns {Promise<Array<object> >} the array of the object having an id and\r\n *      the name.\r\n */\r\nGdfs.prototype.getPaths = async function(path) {\r\n    debug(\"No tests pass: Gdfs#getPaths\");\r\n    debug(`getPaths(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(\"getPaths: Error: the path must be absolute\");\r\n        return null;\r\n    }\r\n    const paths = [ { id:\"root\", name:\"\", mimeType: Gdfs.mimeTypeFolder } ];\r\n    for(const name of path.elements().slice(1)) {\r\n        if(name === \"\") {\r\n            break;\r\n        }\r\n        const parent = paths.slice(-1)[0];\r\n        debug(`name: ${name}, parent: ${JSON.stringify(parent)}`);\r\n        const path = { id: null, name: null, mimeType: null };\r\n        if(parent.id != null) {\r\n            const children = await Gdfs.findFileByName(parent.id, name);\r\n            if(children.length > 0) {\r\n                const child = children.shift();\r\n                path.id = child.id;\r\n                path.name = child.name;\r\n                path.mimeType = child.mimeType;\r\n            }\r\n        }\r\n        paths.push(path);\r\n    }\r\n    debug(`getPaths: ${JSON.stringify(paths, null, \"  \")}`);\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Get the file object that the path points to.\r\n * @param {GdfsPath} path the path.\r\n * @returns {file} the file object of google drive.\r\n */\r\nGdfs.prototype.getFileOfPath = async function(path) {\r\n    const paths = await this.getPaths(path);\r\n    if(!paths) {\r\n        return null;\r\n    }\r\n    return paths.slice(-1)[0];\r\n};\r\n\r\n/**\r\n * Get the current working directory of gdrive-fs.\r\n * @returns {string} The current working directory.\r\n */\r\nGdfs.prototype.cwd = function() {\r\n    return this.getCurrentPath().toString();\r\n};\r\n\r\n/**\r\n * Changes the current working directory of this client session.\r\n * @param {string} directory A pathname to operate.\r\n * @async\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdir = async function(directory) {\r\n    debug(\"No tests pass: Gdfs#chdir\");\r\n    const cwd = this.getCurrentPath();\r\n    const next_cwd = GdfsPath.merge(cwd, new GdfsPath(directory));\r\n    return await this.setCurrentPath(next_cwd);\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @async\r\n * @param {string} folderId A destination file id to move.\r\n *      To move to parent, \"..\" is available.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdirById = async function(folderId) {\r\n    debug(`Gdfs.chdirById( ${folderId} )`);\r\n    if(folderId === \".\") {\r\n        return true;\r\n    }\r\n    const currentFolderId = this.getCurrentFolderId();\r\n    if(folderId === \"/\" || folderId === \"root\" ) {\r\n        this._currentPath = [ { id:\"root\", name:\"\" } ];\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId === \"..\") {\r\n        if(currentFolderId === \"root\") {\r\n            debug(\"Could not move to upper folder from root.\");\r\n            return false;\r\n        }\r\n        this._currentPath.pop();\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId !== currentFolderId) {\r\n        const paths = [];\r\n        const root = await Gdfs.getFileResource({fileId: \"root\", fields: \"id\"});\r\n        let searchId = folderId;\r\n        for(;;) {\r\n            const file = await Gdfs.getFileResource({\r\n                fileId: searchId,\r\n                fields: \"id, name, parents, mimeType\",\r\n            });\r\n            if(file == null) {\r\n                debug(`folder ${searchId} is not found.`);\r\n                return false;\r\n            }\r\n            if(file.mimeType !== Gdfs.mimeTypeFolder) {\r\n                debug(`folder ${searchId} is not folder.`);\r\n                return false;\r\n            }\r\n            debug(JSON.stringify(file, null,  \"  \"));\r\n            if(file.id == root.id) {\r\n                paths.unshift({id: \"root\", name: \"\" });\r\n                break;\r\n            } else {\r\n                paths.unshift({id: file.id, name: file.name });\r\n            }\r\n            searchId = file.parents.shift();\r\n        }\r\n        debug(JSON.stringify(paths, null, \"  \"));\r\n        this._currentPath = paths;\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * Check the path is a directory.\r\n * @async\r\n * @param {GdfsPath} path A path to check\r\n * @returns {Promise<Boolean>} The path is a directory or not.\r\n */\r\nGdfs.prototype.isDirectory = async function(path) {\r\n    debug(\"No tests pass: Gdfs#isDirectory\");\r\n    const file = await this.getFileOfPath(this.toAbsolutePath(path));\r\n    if(!file) {\r\n        return false;\r\n    }\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Convert to absolute path.\r\n * @param {GdfsPath} path path to be converted\r\n * @returns {GdfsPath} An absolute path\r\n */\r\nGdfs.prototype.toAbsolutePath = function(path) {\r\n    debug(\"No tests pass: Gdfs#toAbsolutePath\");\r\n    if(path.isAbsolute()) {\r\n        return path;\r\n    }\r\n    const cwd = this.getCurrentPath();\r\n    return GdfsPath.merge(cwd, path);\r\n};\r\n\r\n/**\r\n * Read the directory to get a list of filenames.\r\n *\r\n * This method may not returns all files in the directory.\r\n * To know all files were listed, check the `pageToken` field in the parameter\r\n * `options` after the invocation.\r\n * If the reading was completed, the field would be set `null`.\r\n * The rest files unread will be returned at the next invocation with same\r\n * parameters.\r\n *\r\n * ```javascript\r\n * const readDirAll = async path => {\r\n *     const opts = { pageSize: 10, pageToken: null };\r\n *     const files = [];\r\n *     do {\r\n *        for(const fn of await files.readdir(path, opts)) {\r\n *            files.push(fn);\r\n *        }\r\n *     } while(opts.pageToken != null);\r\n * };\r\n * ```\r\n *\r\n * @async\r\n * @since v1.1.0\r\n * @param {string} path A path to the directory.\r\n *\r\n * @param {object|null} options (Optional) options for this method.\r\n *\r\n * Only two fields are available:\r\n *\r\n * * \"pageSize\": Set maximum array size that this method returns at one\r\n * time.  The default value 10 will be used if this is not specified or\r\n * zero or negative value is specified.\r\n * * \"pageToken\": Set null to initial invocation to read from first\r\n * entry. This would be updated other value if the unread files are\r\n * remained. The value is used for reading next files. User should not\r\n * set the value except for null.\r\n *\r\n * If this parameter is ommited, all files will be read.\r\n * This is not recomended feature for the directory that has a number of files.\r\n *\r\n * @returns {Promise<Array<string> >} returns an array of filenames.\r\n */\r\nGdfs.prototype.readdir = async function(path, options) {\r\n    path += path.match(/\\/$/) ? \"\" : \"/\";\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readdir: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n\r\n    if(!Gdfs.isFolder(parentFolder)) {\r\n        debug(`readdir: The path is not a folder ${path}`);\r\n        return null;\r\n    }\r\n\r\n    const files = [];\r\n    const readAll = (options == null);\r\n    options = options || {};\r\n    const pageSize = options.pageSize || 10;\r\n    let pageToken = options.pageToken || null;\r\n\r\n    const readFiles = async params => {\r\n        debug(`readdir: params: ${JSON.stringify(params, null, \"  \")}`);\r\n        const result = await Gdfs.getFileList(params);\r\n        debug(`readdir: result.nextPageToken: ${result.nextPageToken}`);\r\n        for(const file of result.files) {\r\n            files.push(file.name);\r\n        }\r\n        return result.nextPageToken;\r\n    };\r\n\r\n    const params = {\r\n        \"pageSize\": pageSize <= 0 ? 10 : pageSize,\r\n        \"pageToken\": pageToken,\r\n        \"q\": `parents in '${parentFolder.id}' and trashed = false`,\r\n        \"fields\": \"nextPageToken, files(name)\",\r\n    };\r\n\r\n    if(!readAll) {\r\n        // eslint-disable-next-line require-atomic-updates\r\n        options.pageToken = await readFiles(params);\r\n    } else {\r\n        do {\r\n            // eslint-disable-next-line require-atomic-updates\r\n            options.pageToken = await readFiles(params);\r\n        } while(options.pageToken != null);\r\n    }\r\n\r\n    debug(`readdir: files: ${JSON.stringify(files)}`);\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file's properties.\r\n * It is a file resource of Google Drive including id, name, mimeType,\r\n * webContentLink and webViewLink about the file or directory.\r\n *\r\n * @async\r\n * @param {string} path A pathname.\r\n * @returns {File} The file resource of Google Drive including id, name,\r\n *      mimeType, webContentLink and webViewLink about the file or directory.\r\n * @since v1.1.0\r\n */\r\nGdfs.prototype.stat = async function(path) {\r\n    debug(`Gdfs#stat(${path})`);\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    debug(`stat: absPath: ${absPath.toString()}`);\r\n    path = absPath.toString();\r\n    if(path === \"/\") {\r\n        const file = await Gdfs.getFileResource({\r\n            fileId: \"root\",\r\n            fields: \"id, name, mimeType, webContentLink, webViewLink\",\r\n        });\r\n        debug(`stat: file ${JSON.stringify(file)}`);\r\n        return file;\r\n    }\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`stat: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`stat: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`stat: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    if(files.length === 0) {\r\n        debug(`stat: File not found ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    debug(`stat: file ${JSON.stringify(file)}`);\r\n    return file;\r\n};\r\n\r\n/**\r\n * Read a file.\r\n * The file must have webContentLink in its resource to read the contents,\r\n * To get the resource, Use [`Gdfs#stat`](#stat).\r\n *\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<string>} The file content.\r\n */\r\nGdfs.prototype.readFile = async function(path) {\r\n    debug(`Gdfs#readFile(${path})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readFile: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`readFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`readFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`File not found ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(!file.webContentLink) {\r\n        debug(`File is not downloadable ${path}`);\r\n        return null;\r\n    }\r\n    return await Gdfs.downloadFile(file.id);\r\n};\r\n\r\n/**\r\n * Make a directory.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.mkdir = async function(path) {\r\n    debug(`mkdir(${path})`);\r\n\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`mkdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`mkdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`mkdir: pathname: ${pathname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, pathname);\r\n    debug(`mkdir: files: ${JSON.stringify(files)}`);\r\n    if(files.length > 0) {\r\n        debug(`mkdir: The directory exists ${path}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.createFile(\r\n        parentFolder.id, pathname, Gdfs.mimeTypeFolder);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Remove the directory but not a normal file.\r\n * The operation will fail, if it is not a directory nor empty.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.rmdir = async function(path) {\r\n    debug(`rmdir(${path})`);\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`rmdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`rmdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`rmdir: pathname: ${pathname}`);\r\n    if(pathname === \"\") {\r\n        debug(`rmdir: The root directory cannot be removed ${path}`);\r\n        return null;\r\n    }\r\n    const dires = await Gdfs.findFolderByName(parentFolder.id, pathname);\r\n    debug(`rmdir: dires: ${JSON.stringify(dires)}`);\r\n    if(dires.length === 0) {\r\n        debug(`rmdir: The directory not exists ${path}`);\r\n        return null;\r\n    }\r\n    const dir = dires.shift();\r\n    debug(`rmdir: dir ${JSON.stringify(dir)}`);\r\n    debug(`rmdir: _currentPath ${JSON.stringify(this._currentPath, null, \"  \")}`);\r\n    if(this._currentPath.filter(parent => parent.id == dir.id).length > 0 ||\r\n        dir.id === await Gdfs.getActualRootFolderId())\r\n    {\r\n        debug(`rmdir: The path is a parent ${path}`);\r\n        return null;\r\n    }\r\n    if(dir.mimeType !== Gdfs.mimeTypeFolder) {\r\n        debug(`rmdir: The path is not folder ${path}`);\r\n        return null;\r\n    }\r\n    const params = {\r\n        \"q\": `parents in '${dir.id}' and trashed = false`,\r\n        \"fields\": \"files(id)\",\r\n    };\r\n    debug(`rmdir: params ${JSON.stringify(params)}`);\r\n    const children = await Gdfs.getFileList(params);\r\n    debug(`rmdir: children: ${JSON.stringify(children, null, \"  \")}`);\r\n    if(children.files.length > 0) {\r\n        debug(`rmdir: The folder is not empty ${path}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete(\r\n        { fileId: dir.id });\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Delete the file but not directory.\r\n * This does not move the file to the trash-box.\r\n *\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.unlink = async function(path) {\r\n    debug(`unlink(${path})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`unlink: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`unlink: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`unlink: pathname: ${pathname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, pathname);\r\n    debug(`unlink: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`unlink: The file not exists ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`unlink: The file is a folder ${path}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete({ fileId: file.id });\r\n    const result = response.result;\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Write a file.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @param {string} mimeType A mimeType of the file content.\r\n * @param {string} data A file content.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.writeFile = async function(path, mimeType, data) {\r\n    debug(`Gdfs#writeFile(${path},${mimeType}, ${JSON.stringify(data)})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`writeFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`writeFile: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`writeFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`writeFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        const file = await Gdfs.createFile(\r\n            parentFolder.id, filename, mimeType);\r\n        const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n        if(parentFolder.id === this.getCurrentFolderId()) {\r\n            await this.fireCwdUpdate();\r\n        }\r\n        return result;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`writeFile: The path already exists as directory ${path}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\nmodule.exports = Gdfs;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs-ui\");\r\ndebug(\"loading\");\r\nconst Gdfs = require(\"./gdfs.js\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\n\r\n/**\r\n * class GdfsUi\r\n * @constructor\r\n * @param {HTMLElement} The root element that UI widget will be built.\r\n * @param {Gdfs} The gapi client.\r\n */\r\nfunction GdfsUi(element, opt) {\r\n    debug(\"Start of GdfsUi ctor\");\r\n    this._element = element;\r\n    this._gdfs = new Gdfs();\r\n    this._pageSize = 10;\r\n    this._trashed = false;\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    this._opt = {\r\n        onFileListChange: () => {},\r\n        onCurrentDirChange: () => {},\r\n    };\r\n\r\n    opt = opt || {};\r\n    for(const key of Object.keys(this._opt)) {\r\n        if(key in opt) {\r\n            this._opt[key] = opt[key];\r\n        }\r\n    }\r\n\r\n    // events\r\n    this._fileListChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-filelist-change\");\r\n    this._currentDirChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-current-dir-change\");\r\n\r\n    this._currentDirChangeEvent.listen(\r\n        this._opt.onCurrentDirChange);\r\n    this._fileListChangeEvent.listen(\r\n        this._opt.onFileListChange);\r\n\r\n    this._gdfs.onCwdUpdate(async () => {\r\n        debug(\"Start of _gdfs.onCwdUpdate\");\r\n        await this.reload();\r\n        this._currentDirChangeEvent.fire();\r\n        debug(\"End of _gdfs.onCwdUpdate\");\r\n    });\r\n\r\n    const onSignedInStatusChange = async status => {\r\n        debug(\"Start of signInStatusChange\");\r\n        if(status) {\r\n            await this._gdfs.chdir(\"/\");\r\n        }\r\n        debug(\"End of signInStatusChange\");\r\n    };\r\n\r\n    // Listen events\r\n    Gdfs.signInStatusChangeEvent.listen(\r\n        () => onSignedInStatusChange(Gdfs.isSignedIn()));\r\n\r\n    onSignedInStatusChange(Gdfs.isSignedIn());\r\n    debug(\"End of GdfsUi ctor\");\r\n}\r\n\r\n/**\r\n * Returns the listing files in current directory is completed.\r\n * @returns {boolean} true if the listing files is completed.\r\n */\r\nGdfsUi.prototype.isPageCompleted = function() {\r\n    const status = this._pageToken == null;\r\n    return status;\r\n};\r\n\r\n/**\r\n * Get current path as full path.\r\n * @returns {Array<string>} The array of file ids.\r\n */\r\nGdfsUi.prototype.getCurrentPath = function() {\r\n    return this._gdfs._currentPath;\r\n};\r\n\r\n/**\r\n * Get files list on current page.\r\n * @param {number} begin a file index\r\n * @param {number} end a file index\r\n * @returns {Array<File>} the files in current page.\r\n */\r\nGdfsUi.prototype.getFiles = async function(begin, end) {\r\n    debug(`GdfsUi#getFiles param:{begin:${begin}, end:${end})}`);\r\n    debug(`_pageToken: ${this._pageToken}`);\r\n    if(this._pageToken == null) {\r\n        this._files = [];\r\n    }\r\n    while(end > this._files.length) {\r\n        await this.readDir();\r\n        this._fileListChangeEvent.fire();\r\n        if(this._pageToken == null) {\r\n            break;\r\n        }\r\n    }\r\n    return this._files.slice(begin, end);\r\n};\r\n\r\n/**\r\n * Read the files on current directory.\r\n * @async\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.readDir = async function() {\r\n\r\n    const andConditionsOfQuerySearchClauses = [\r\n        `parents in '${this._gdfs.getCurrentFolderId()}'`,\r\n        `trashed = ${this._trashed?\"true\":\"false\"}`,\r\n    ];\r\n\r\n    const queryParameters = {\r\n        \"pageSize\": this._pageSize,\r\n        \"pageToken\": this._pageToken,\r\n        \"q\": andConditionsOfQuerySearchClauses.join(\" and \"),\r\n        \"fields\": \"nextPageToken, files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    const result = await Gdfs.getFileList(queryParameters);\r\n    this._pageToken = result.nextPageToken;\r\n    for(const file of result.files) {\r\n        this._files.push(file);\r\n    }\r\n};\r\n\r\n/**\r\n * Reload the file list.\r\n * @async\r\n * @returns {Promise} to sync\r\n */\r\nGdfsUi.prototype.reload = async function() {\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    await this.readDir();\r\n    this._fileListChangeEvent.fire();\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @param {string} folderId A destination file id to move.\r\n * To move to parent, \"..\" is available.\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.chdirById = async function(folderId) {\r\n    await this._gdfs.chdirById(folderId);\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {string} fileId The file id of the target file.\r\n * @returns {Promise<object>} The resource object.\r\n */\r\nGdfsUi.prototype.getFileResource = async function(fileId) {\r\n    return await Gdfs.getFileResource({\r\n        \"fileId\": fileId,\r\n    });\r\n};\r\n\r\n/**\r\n * Upload a file.\r\n * @param {File} file the file to be uploaded.\r\n * @return {Promise<File>} an uploaded File.\r\n */\r\nGdfsUi.prototype.uploadFile = function (file) {\r\n    return new Promise( (resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n            resolve(await this.writeFile(\r\n                file.name, file.type, reader.result));\r\n        };\r\n        reader.onerror = event => {\r\n            reject(new Error([\r\n                \"Fail to upload. Could not read the file \",\r\n                `${file.name}(${event.type}).`,\r\n            ].join(\"\")));\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n};\r\n\r\n/**\r\n * Create or overwrite a file to current directory.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The content type.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of update.\r\n */\r\nGdfsUi.prototype.writeFile = async function (\r\n    filename, mimeType, data)\r\n{\r\n    // Find same file in current directory\r\n    const fileIds = this._files\r\n        .filter(file => (file.name === filename))\r\n        .map( file => file.id );\r\n\r\n    if(fileIds.length == 0) {\r\n        //Create new file\r\n        const response = await Gdfs.createFile(\r\n            this._gdfs.getCurrentFolderId(), filename, mimeType);\r\n        const file = JSON.parse(response);\r\n        return await Gdfs.updateFile(\r\n            file.id, mimeType, data);\r\n    }\r\n\r\n    // Overwrite the file\r\n    return await Gdfs.updateFile(\r\n        fileIds[0], mimeType, data);\r\n};\r\n\r\nmodule.exports = GdfsUi;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdrive-fs\");\r\nconst Gdfs = require(\"./lib/gdfs.js\");\r\nGdfs.Ui = require(\"./lib/gdfs-ui.js\");\r\nGdfs.Path = require(\"./lib/gdfs-path.js\");\r\ntry {\r\n    const context = (Function(\"return this;\"))();\r\n    if(context === window) {\r\n        window.Gdfs = Gdfs;\r\n    }\r\n} catch(err) {\r\n    debug(err.message);\r\n}\r\nmodule.exports = Gdfs;\r\n"]}