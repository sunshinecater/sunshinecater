{"version":3,"sources":["node_modules/debug/node_modules/ms/index.js","node_modules/debug/src/common.js","node_modules/process/browser.js","node_modules/debug/src/browser.js","lib/gdfs-event.js","lib/gdfs-path.js","lib/gdfs.js","lib/gdfs-ui.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","_typeof","obj","Symbol","iterator","constructor","useColors","window","type","__nwjs","navigator","userAgent","toLowerCase","match","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","parseInt","RegExp","$1","formatArgs","namespace","humanize","diff","c","color","splice","index","lastC","replace","log","_console","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","localstorage","localStorage","colors","require","formatters","j","v","JSON","stringify","message","debug","GdfsEvent","target","eventName","_target","_eventName","listen","handler","addEventListener","event","fire","extraData","Event","key","Object","keys","dispatchEvent","GdfsPath","pathname","_lastSlash","_absolute","_paths","undefined","parse","getPathPart","toString","paths","elements","join","getFilename","pop","map","item","unshift","merge","p","reduce","pathA","pathB","a","b","isAbsolute","joined","split_path","escaped","element","chars","split","lastSlash","absolute","shift","replacement","acc","next","isArray","last","isDirSpec","rootSpec","dirSpec","Gdfs","_oncwdupdate","_currentPath","id","createClient","signInStatusChangeEvent","loadApi","clientId","apiKey","script","createElement","setAttribute","Promise","resolve","reject","onload","gapi","client","init","discoveryDocs","scope","auth2","getAuthInstance","isSignedIn","readyState","onerror","URIError","src","body","appendChild","mimeTypeFolder","get","signIn","signOut","getFileList","response","drive","files","list","queryParameters","result","findFolderByName","parentFolderId","folderName","folders","params","q","file","pageToken","nextPageToken","err","stack","findFileByName","fileName","getFileResource","parameters","isFolder","mimeType","downloadFile","fileId","acknowledgeAbuse","requestWithAuth","alt","createFile","folderId","filename","parents","updateFile","data","uploadType","method","endpoint","queryParams","headers","xhr","XMLHttpRequest","open","createUrl","forEach","setRequestHeader","getAccessToken","responseText","statusText","ontimeout","send","accessToken","currentUser","getAuthResponse","access_token","filter","value","encodeURI","getActualRootFolderId","res","fields","onCwdUpdate","prev","fireCwdUpdate","getCurrentFolderId","slice","getCurrentPath","path","setCurrentPath","isDirectory","getPaths","parent","children","child","getFileOfPath","directory","next_cwd","chdirById","currentFolderId","root","searchId","toAbsolutePath","readdir","options","absPath","parentFolder","readAll","pageSize","readFiles","stat","readFile","webContentLink","mkdir","rmdir","dires","delete","unlink","writeFile","GdfsUi","opt","_element","_gdfs","_pageSize","_trashed","_pageToken","_files","_opt","onFileListChange","onCurrentDirChange","_fileListChangeEvent","_currentDirChangeEvent","reload","onSignedInStatusChange","status","isPageCompleted","getFiles","begin","end","readDir","andConditionsOfQuerySearchClauses","uploadFile","reader","FileReader","readAsArrayBuffer","fileIds","Ui","Path","Function"],"mappings":"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","file":"gdrive-fs.min.js","sourceRoot":"..","sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = require('ms');\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = require('./common')(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsEvent\");\r\n/**\r\n * Event class\r\n * @constructor\r\n * @param {HTMLElement} target An element that dispatch\r\n * @param {string} eventName An event name\r\n */\r\nfunction GdfsEvent(target, eventName) {\r\n    this._target = target;\r\n    this._eventName = eventName;\r\n}\r\n\r\n/**\r\n * Listen this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.listen = function(handler) {\r\n    debug(`GdfsEvent.listen: ${this._eventName}=>${handler.constructor.name}`);\r\n    if(handler.constructor.name === \"AsyncFunction\") {\r\n        this._target.addEventListener(\r\n            this._eventName, async event => await handler(event));\r\n    } else {\r\n        this._target.addEventListener(\r\n            this._eventName, handler);\r\n    }\r\n};\r\n\r\n/**\r\n * Fire this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.fire = function(extraData = {}) {\r\n    const event = new Event(this._eventName);\r\n    for(const key of Object.keys(extraData)) {\r\n        event[key] = extraData[key];\r\n    }\r\n    debug(\r\n        `GdfsEvent.fire: ${this._eventName}`,\r\n        `extraData: ${JSON.stringify(extraData)}`);\r\n    this._target.dispatchEvent(event);\r\n};\r\n\r\nmodule.exports = GdfsEvent;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsPath\");\r\ndebug(\"loading\");\r\n\r\n/**\r\n * Gdfs Path class.\r\n * @constructor\r\n * @param {string|undefined} pathname initial path.\r\n */\r\nfunction GdfsPath(pathname) {\r\n    this._lastSlash = true;\r\n    this._absolute = true;\r\n    this._paths = [];\r\n    if(pathname != undefined) {\r\n        this.parse(pathname);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Get a part of path.\r\n * @returns {GdfsPath} A path object including only path.\r\n */\r\nGdfsPath.prototype.getPathPart = function() {\r\n    if(this._lastSlash) {\r\n        return new GdfsPath(this.toString());\r\n    }\r\n    const paths = this.elements();\r\n    paths.splice(-1, 1, \"\");\r\n    debug(`getPathPart: paths: ${JSON.stringify(paths)}`);\r\n    return new GdfsPath(paths.join(\"/\"));\r\n};\r\n\r\n/**\r\n * Get filename part of path.\r\n * @returns {string} A filename.\r\n */\r\nGdfsPath.prototype.getFilename = function() {\r\n    return this.elements().pop();\r\n};\r\n\r\n/**\r\n * Get paths elements.\r\n * @returns {Array<string>} the elements.\r\n */\r\nGdfsPath.prototype.elements = function() {\r\n    const elements = this._paths.map(item => item);\r\n    if(this._absolute) {\r\n        elements.unshift(\"\");\r\n    }\r\n    if(this._lastSlash) {\r\n        elements.push(\"\");\r\n    }\r\n    return elements;\r\n};\r\n\r\n/**\r\n * Create a new path object with joining the two paths.\r\n * \r\n * @param {Array<GdfsPath>} paths The paths to join.\r\n * @returns {GdfsPath} The path that was joined.\r\n */\r\nGdfsPath.merge = (...paths) => {\r\n    debug(`Gdfs.merge: ${paths.map(p=>p.toString()).join(\" | \")}`);\r\n    return paths.reduce( (pathA, pathB, index) => {\r\n        debug(`Gdfs.merge: Reducing #${index}`);\r\n        debug(`Gdfs.merge: pathA: ${pathA.toString()}`);\r\n        debug(`Gdfs.merge: pathB: ${pathB.toString()}`);\r\n        if(typeof(pathA) === \"string\") {\r\n            pathA = new GdfsPath(pathA);\r\n        }\r\n        if(typeof(pathB) === \"string\") {\r\n            pathB = new GdfsPath(pathB);\r\n        }\r\n        const a = pathA.toString();\r\n        const b = pathB.toString();\r\n        if(pathB.isAbsolute()) {\r\n            debug(`returns ${b}`);\r\n            return new GdfsPath(b);\r\n        }\r\n        const joined = new GdfsPath([a, b].join(\"/\"));\r\n        debug(`Gdfs.merge: returns ${joined.toString()}`);\r\n        return joined;\r\n    });\r\n};\r\n\r\nconst split_path = pathname => {\r\n    const paths = [];\r\n    let escaped = false;\r\n    let i = 0;\r\n    let element = \"\";\r\n    let chars = pathname.split(\"\");\r\n    while(i < chars.length) {\r\n        const c = chars[i];\r\n        if(escaped) {\r\n            element += c;\r\n            escaped = false;\r\n        } else if(c === \"\\\\\"){\r\n            escaped = true;\r\n        } else if(c === \"/\") {\r\n            paths.push(element);\r\n            element = \"\";\r\n        } else {\r\n            element += c;\r\n        }\r\n        i++;\r\n    }\r\n    paths.push(element);\r\n    if(escaped) {\r\n        throw new Error(`Invalid pathname ${pathname}`);\r\n    }\r\n    if(paths.length == 0) {\r\n        throw new Error(\"Invalid pathname. It should not be empty.\");\r\n    }\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Set a path repersented by a string.\r\n * @param {string} pathname A path name to parse\r\n * @return {undefined}\r\n */\r\nGdfsPath.prototype.parse = function(pathname) {\r\n    let paths = split_path(pathname.replace(/\\/+/g, \"/\"));\r\n    debug(`parse ${JSON.stringify(pathname)} => ${JSON.stringify(paths)}`);\r\n    const lastSlash = (paths[paths.length - 1] === \"\");\r\n    const absolute = (paths[0] === \"\");\r\n    if(lastSlash) {\r\n        paths.pop();\r\n    }\r\n    if(absolute) {\r\n        paths.shift();\r\n    }\r\n    this._lastSlash = !!lastSlash;\r\n    this._absolute = !!absolute;\r\n    for(;;) {\r\n        let replacement = false;\r\n        if(paths.length >= 2) {\r\n            paths = paths.reduce( (acc, next) => {\r\n                if(!Array.isArray(acc)) {\r\n                    acc = [acc];\r\n                }\r\n                const last = acc[acc.length - 1];\r\n                if(last !== \"..\" && next === \"..\") {\r\n                    acc.pop();\r\n                    replacement = true;\r\n                } else if(last !== \".\" && next === \".\") {\r\n                    replacement = true;\r\n                } else {\r\n                    acc.push(next);\r\n                }\r\n                return acc;\r\n            });\r\n        }\r\n        if(!replacement) {\r\n            this._paths = paths;\r\n            debug(`this._paths:${JSON.stringify(this._paths)}`);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns if this represents an absolute path.\r\n * @returns {Boolean} True if this represents an absolute path, otherwise false.\r\n */\r\nGdfsPath.prototype.isAbsolute = function() {\r\n    return this._absolute;\r\n};\r\n\r\n/**\r\n * Returns if this represents a directory.\r\n * @returns {Boolean} True if this represents a directory, otherwise false.\r\n */\r\nGdfsPath.prototype.isDirSpec = function() {\r\n    return this._lastSlash;\r\n};\r\n\r\n/**\r\n * Returns a path represented by string.\r\n * @returns {string} The path that this is representing.\r\n */\r\nGdfsPath.prototype.toString = function() {\r\n    if(this._paths.length === 0) {\r\n        return \"/\";\r\n    }\r\n    const rootSpec = this._absolute ? \"/\" : \"\";\r\n    const dirSpec = this._lastSlash ? \"/\" : \"\";\r\n    const pathname = `${rootSpec}${this._paths.join(\"/\")}${dirSpec}`;\r\n    return pathname;\r\n};\r\n\r\nmodule.exports = GdfsPath;\r\n","/*global gapi:false*/\r\n\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs\");\r\ndebug(\"loading\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\nconst GdfsPath = require(\"./gdfs-path.js\");\r\n\r\n/**\r\n * Gdfs class is an interface for the Google Drive API v3.\r\n *\r\n * The instance manages a current working directory(CWD) and offers methods\r\n * to operate files and folders on the Google Drive by its pathname.\r\n *\r\n * Before creating an instance, the APIs must be loaded by the class method\r\n * [`loadApi`](#.loadApi) with a ClientId and ApiKey.\r\n * These had to be created in a project of Google devloper Console.\r\n *\r\n * And to operates files, user must sign-in with the Google account.\r\n * See [signIn](#.signIn) and [signOut](#.signOut).\r\n *\r\n * Instance's CWD is initialized to the root on constructor. It can be changed\r\n * by [chdir](#chdir) method. When it is changed, the 'oncwdupdate' callback\r\n * is fired. To know where the CWD is, The [cwd](#cwd) method is available.\r\n *\r\n * @constructor\r\n */\r\nfunction Gdfs() {\r\n    this._oncwdupdate = null;\r\n    this._currentPath = [{ id: \"root\", name: \"\", }];\r\n}\r\n\r\n/**\r\n * Create Gdfs client.\r\n * @returns {Gdfs} The google drive interface that has a current directory.\r\n */\r\nGdfs.createClient = () => {\r\n    return new Gdfs();\r\n};\r\n\r\n/**\r\n * signInStatusChangeEvent\r\n * @type {GdfsEvent}\r\n */\r\nGdfs.signInStatusChangeEvent = new GdfsEvent(\r\n    window, \"gdfs-signin-status-change\");\r\n\r\n/**\r\n * Load Google Drive APIs and initialize its client object.\r\n *\r\n * The loaded all APIs are accessible with a global `gapi` object.\r\n * But it is wrapped by this class so the users should not use it directly.\r\n *\r\n * @param {string} clientId A clientId from the Developer console.\r\n * @param {string} apiKey An apiKey from the Developer console.\r\n * @returns {Promise} A promise that will be resolved when the loading completed.\r\n */\r\nGdfs.loadApi = (clientId, apiKey) => {\r\n    debug(\"Start of Gdfs.loadApi\");\r\n    const script = document.createElement(\"SCRIPT\");\r\n    script.setAttribute(\"async\", \"async\");\r\n    script.setAttribute(\"src\", \"https://apis.google.com/js/api.js\");\r\n    const p = new Promise( (resolve, reject) => {\r\n        script.addEventListener(\"load\", () => {\r\n            script.onload = () => {};\r\n            gapi.load(\"client:auth2\", async () => {\r\n                debug(\"initialize gapi.client\");\r\n\r\n                if(typeof(clientId) === \"object\" && apiKey == null &&\r\n                    \"clientId\" in clientId && \"apiKey\" in clientId &&\r\n                    \"discoveryDocs\" in clientId && \"scope\" in clientId)\r\n                {\r\n                    await gapi.client.init(clientId);\r\n                } else {\r\n                    await gapi.client.init({\r\n                        clientId: clientId, apiKey: apiKey,\r\n                        discoveryDocs: [\r\n                            \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\r\n                        ],\r\n                        scope: [\r\n                            \"https://www.googleapis.com/auth/drive\",\r\n                            \"https://www.googleapis.com/auth/drive.appdata\",\r\n                            \"https://www.googleapis.com/auth/drive.file\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.photos.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.readonly\",\r\n                        ].join(\" \"),\r\n                    });\r\n                }\r\n                gapi.auth2.getAuthInstance().isSignedIn.listen( () => {\r\n                    debug(\"the signed-in-status changed\");\r\n                    Gdfs.signInStatusChangeEvent.fire();\r\n                });\r\n                Gdfs.signInStatusChangeEvent.fire();\r\n                debug(`Gdfs.loadApi SignedIn: ${Gdfs.isSignedIn()}`);\r\n                debug(\"Gdfs.loadApi is resolved\");\r\n                resolve();\r\n            });\r\n        });\r\n        script.addEventListener(\"readystatechange\", () => {\r\n            debug(`readystatechange ${script.readyState}`);\r\n            if(script.readyState === \"complete\") {\r\n                script.onload();\r\n            }\r\n        });\r\n        script.onerror = event => {\r\n            debug(\"Gdfs.loadApi is rejected\");\r\n            reject(new URIError(\r\n                `The script ${event.target.src} is not accessible.`));\r\n        };\r\n        document.body.appendChild(script);\r\n    });\r\n    debug(\"End of Gdfs.loadApi\");\r\n    return p;\r\n};\r\n\r\n/**\r\n * A mime type of the Google Drive's folder.\r\n * @type {string}\r\n */\r\nGdfs.mimeTypeFolder = \"application/vnd.google-apps.folder\";\r\n\r\n/**\r\n * Check if gapi was signed in.\r\n * @returns {boolean} true if gapi is signed in, otherwise false.\r\n */\r\nGdfs.isSignedIn = () => {\r\n    return gapi.auth2.getAuthInstance().isSignedIn.get();\r\n};\r\n\r\n/**\r\n * Sign in to Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signIn = async () => {\r\n    return await gapi.auth2.getAuthInstance().signIn();\r\n};\r\n\r\n/**\r\n * Sign out from the Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signOut = async () => {\r\n    return await gapi.auth2.getAuthInstance().signOut();\r\n};\r\n\r\n/**\r\n * Get file list.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileList = async (queryParameters) => {\r\n    const response = await gapi.client.drive.files.list(queryParameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Find a folder by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} folderName A folder name to find\r\n * @returns {Array<object>} A folder list that found.\r\n */\r\nGdfs.findFolderByName = async (parentFolderId, folderName) => {\r\n    debug(\"No tests pass: Gdfs.findFolderByName\");\r\n\r\n    const folders = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${folderName}'`,\r\n        `mimeType = '${Gdfs.mimeTypeFolder}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`${JSON.stringify(params)}`);\r\n    try {\r\n        do {\r\n            const result = await Gdfs.getFileList(params);\r\n            debug(`${JSON.stringify(result)}`);\r\n            for(const file of result.files) {\r\n                folders.push(file);\r\n            }\r\n            params.pageToken = result.nextPageToken;\r\n        } while(params.pageToken != null);\r\n    } catch(err) {\r\n        debug(err.stack);\r\n    }\r\n\r\n    return folders;\r\n};\r\n\r\n/**\r\n * Find a file by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} fileName A file name to find\r\n * @returns {Promise<Array<object> >} A folder list that found.\r\n */\r\nGdfs.findFileByName = async (parentFolderId, fileName) => {\r\n    debug(\"No tests pass: Gdfs.findFileByName\");\r\n\r\n    const files = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${fileName}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`findFileByName: params: ${JSON.stringify(params, null, \"  \")}`);\r\n    do {\r\n        const result = await Gdfs.getFileList(params);\r\n        for(const file of result.files) {\r\n            debug(`findFileByName: found file: ${JSON.stringify(file)}`);\r\n            files.push(file);\r\n        }\r\n        debug(`findFileByName: result.nextPageToken: ${result.nextPageToken}`);\r\n        params.pageToken = result.nextPageToken;\r\n    } while(params.pageToken != null);\r\n\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileResource = async (parameters) => {\r\n    const response = await gapi.client.drive.files.get(parameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Check if the file is a folder.\r\n * @param {object} file The file object provided from the result\r\n * of `getFileList` method.\r\n * @returns {boolean} The file is a folder or not.\r\n */\r\nGdfs.isFolder = (file) => {\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Get a file content as text from Google Drive.\r\n * Even if the file is not a text actually, it could be converted\r\n * to ArrayBuffer, Blob or JSON to use by Web App.\r\n * @param {string} fileId The file id to download.\r\n * @param {boolean|null} acknowledgeAbuse A user acknowledgment\r\n * status for the potential to abuse. This parameter is optional.\r\n * default value is false.\r\n * @returns {Promise<string>} A downloaded content as text.\r\n */\r\nGdfs.downloadFile = (fileId, acknowledgeAbuse) => {\r\n    return requestWithAuth(\"GET\",\r\n        \"https://www.googleapis.com/drive/v3/files/\"+fileId,\r\n        { alt: \"media\", acknowledgeAbuse : acknowledgeAbuse });\r\n};\r\n\r\n/**\r\n * Create a new file's resource.\r\n * @param {string} folderId The folder id where the file is created.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The mime type for the new file.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.createFile = async (folderId, filename, mimeType) => {\r\n    const response = await requestWithAuth(\"POST\",\r\n        \"https://www.googleapis.com/drive/v3/files\", {},\r\n        { \"Content-Type\": \"application/json\", },\r\n        JSON.stringify({\r\n            name: filename,\r\n            mimeType: mimeType,\r\n            parents: [folderId],\r\n        }));\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * Upload a file content to update a existing file.\r\n * @param {string} fileId The file id to update.\r\n * @param {string} mimeType The content type of the file.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.updateFile = async (fileId, mimeType, data) => {\r\n    const response = await requestWithAuth(\"PATCH\",\r\n        \"https://www.googleapis.com/upload/drive/v3/files/\"+fileId,\r\n        { uploadType: \"media\" },\r\n        { \"Content-Type\": mimeType },\r\n        data);\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * @param {string} method The request method.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object} queryParams The query parameters.\r\n * @param {object} headers The request headers.\r\n * @param {any} body The request body.\r\n * @returns {Promise<object>} The response of the request.\r\n */\r\nconst requestWithAuth = (method, endpoint, queryParams, headers, body) => {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open(method, createUrl(endpoint, queryParams), true);\r\n    headers = headers || {};\r\n    Object.keys(headers).forEach( name => {\r\n        xhr.setRequestHeader(name, headers[name]);\r\n    });\r\n    xhr.setRequestHeader(\"Authorization\",\r\n        \"Bearer \" + getAccessToken());\r\n    xhr.timeout = 30000;\r\n    return new Promise( (resolve, reject) => {\r\n        xhr.onload = () => { resolve(xhr.responseText); };\r\n        xhr.onerror = () => { reject(new Error(xhr.statusText)); };\r\n        xhr.ontimeout = () => { reject(new Error(\"request timeout\")); };\r\n        xhr.send(body);\r\n    });\r\n};\r\n\r\n/**\r\n * Get access-token on current session.\r\n * @returns {string} The access token.\r\n */\r\nconst getAccessToken = () => {\r\n    const googleUser = gapi.auth2.getAuthInstance().currentUser.get();\r\n    const authResponse = googleUser.getAuthResponse(true);\r\n    const accessToken = authResponse.access_token;\r\n    return accessToken;\r\n};\r\n\r\n/**\r\n * Create URI including query parameters.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object|null} params The query parameters.\r\n * @returns {string} The URI.\r\n */\r\nconst createUrl = (endpoint, params) => {\r\n    if(params == null) {\r\n        return endpoint;\r\n    }\r\n    let keys = Object.keys(params).filter(\r\n        key => (key !== \"\"));\r\n    if(keys.length == 0) {\r\n        return endpoint;\r\n    }\r\n    let queryString = keys.map( key => {\r\n        let value = params[key];\r\n        return (value == null ? null : `${key}=${encodeURI(value)}`);\r\n    }).join(\"&\");\r\n    return `${endpoint}?${queryString}`;\r\n};\r\n\r\n/**\r\n * Get actual root folder id.\r\n * @async\r\n * @return {Promise<string>} The root folder's id\r\n */\r\nGdfs.getActualRootFolderId = async () => {\r\n    const res = await Gdfs.getFileResource({ fileId: \"root\", fields: \"id\" });\r\n    debug(`getActualRootFolderId: res ${JSON.stringify(res, null, \"  \")}`);\r\n    return res.id;\r\n};\r\n\r\n/**\r\n * Set oncwdchage callback hander.\r\n * @param {FUnction|AsyncFunction} handler a function to be invoked when\r\n *      the current directory is changed.\r\n * @returns {undefined|Function} the previous handler will be returned.\r\n */\r\nGdfs.prototype.onCwdUpdate = function(handler) {\r\n    const prev = this._oncwdupdate;\r\n    if(handler != null) {\r\n        this._oncwdupdate = handler;\r\n    }\r\n    return prev;\r\n};\r\n\r\n/**\r\n * Fire cwdUpdate.\r\n * @returns {Promise} what the handler returns.\r\n */\r\nGdfs.prototype.fireCwdUpdate = async function() {\r\n    if(this._oncwdupdate) {\r\n        try {\r\n            const result = this._oncwdupdate();\r\n            if(result != null) {\r\n                if(result.constructor === Promise) {\r\n                    return await result;\r\n                }\r\n                return result;\r\n            }\r\n        } catch (err) {\r\n            debug(err.stack);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Get current folder id.\r\n * @returns {string} The folder id that the instance is.\r\n */\r\nGdfs.prototype.getCurrentFolderId = function() {\r\n    return this._currentPath.slice(-1)[0].id;\r\n};\r\n\r\n/**\r\n * Get current working directory as path object.\r\n * @returns {GdfsPath} the current working directory.\r\n */\r\nGdfs.prototype.getCurrentPath = function() {\r\n    const path = this._currentPath.map( path => `${path.name}/`).join(\"\");\r\n    const cwd = new GdfsPath(path);\r\n    debug(`getCurrentPath: ${cwd.toString()}`);\r\n    return cwd;\r\n};\r\n\r\n/**\r\n * Set current working directory with path object.\r\n * @async\r\n * @param {GdfsPath} path the new current working directory.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.setCurrentPath = async function(path) {\r\n    debug(\"No tests pass: Gdfs#setCurrentPath\");\r\n    debug(`setCurrentPath(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(`The path must be absolute. ${path}`);\r\n        return false;\r\n    }\r\n    if(!(await this.isDirectory(path))) {\r\n        debug(`${path} is not a directory`);\r\n        return false;\r\n    }\r\n    this._currentPath = await this.getPaths(path);\r\n    await this.fireCwdUpdate();\r\n    return true;\r\n};\r\n\r\n/**\r\n * Get an array of path element from root directory.\r\n * @async\r\n * @param {GdfsPath} path path object.\r\n * @returns {Promise<Array<object> >} the array of the object having an id and\r\n *      the name.\r\n */\r\nGdfs.prototype.getPaths = async function(path) {\r\n    debug(\"No tests pass: Gdfs#getPaths\");\r\n    debug(`getPaths(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(\"getPaths: Error: the path must be absolute\");\r\n        return null;\r\n    }\r\n    const paths = [ { id:\"root\", name:\"\", mimeType: Gdfs.mimeTypeFolder } ];\r\n    for(const name of path.elements().slice(1)) {\r\n        if(name === \"\") {\r\n            break;\r\n        }\r\n        const parent = paths.slice(-1)[0];\r\n        debug(`name: ${name}, parent: ${JSON.stringify(parent)}`);\r\n        const path = { id: null, name: null, mimeType: null };\r\n        if(parent.id != null) {\r\n            const children = await Gdfs.findFileByName(parent.id, name);\r\n            if(children.length > 0) {\r\n                const child = children.shift();\r\n                path.id = child.id;\r\n                path.name = child.name;\r\n                path.mimeType = child.mimeType;\r\n            }\r\n        }\r\n        paths.push(path);\r\n    }\r\n    debug(`getPaths: ${JSON.stringify(paths, null, \"  \")}`);\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Get the file object that the path points to.\r\n * @param {GdfsPath} path the path.\r\n * @returns {file} the file object of google drive.\r\n */\r\nGdfs.prototype.getFileOfPath = async function(path) {\r\n    const paths = await this.getPaths(path);\r\n    if(!paths) {\r\n        return null;\r\n    }\r\n    return paths.slice(-1)[0];\r\n};\r\n\r\n/**\r\n * Get the current working directory of gdrive-fs.\r\n * @returns {string} The current working directory.\r\n */\r\nGdfs.prototype.cwd = function() {\r\n    return this.getCurrentPath().toString();\r\n};\r\n\r\n/**\r\n * Changes the current working directory of this client session.\r\n * @param {string} directory A pathname to operate.\r\n * @async\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdir = async function(directory) {\r\n    debug(\"No tests pass: Gdfs#chdir\");\r\n    const cwd = this.getCurrentPath();\r\n    const next_cwd = GdfsPath.merge(cwd, new GdfsPath(directory));\r\n    return await this.setCurrentPath(next_cwd);\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @async\r\n * @param {string} folderId A destination file id to move.\r\n *      To move to parent, \"..\" is available.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdirById = async function(folderId) {\r\n    debug(`Gdfs.chdirById( ${folderId} )`);\r\n    if(folderId === \".\") {\r\n        return true;\r\n    }\r\n    const currentFolderId = this.getCurrentFolderId();\r\n    if(folderId === \"/\" || folderId === \"root\" ) {\r\n        this._currentPath = [ { id:\"root\", name:\"\" } ];\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId === \"..\") {\r\n        if(currentFolderId === \"root\") {\r\n            debug(\"Could not move to upper folder from root.\");\r\n            return false;\r\n        }\r\n        this._currentPath.pop();\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId !== currentFolderId) {\r\n        const paths = [];\r\n        const root = await Gdfs.getFileResource({fileId: \"root\", fields: \"id\"});\r\n        let searchId = folderId;\r\n        for(;;) {\r\n            const file = await Gdfs.getFileResource({\r\n                fileId: searchId,\r\n                fields: \"id, name, parents, mimeType\",\r\n            });\r\n            if(file == null) {\r\n                debug(`folder ${searchId} is not found.`);\r\n                return false;\r\n            }\r\n            if(file.mimeType !== Gdfs.mimeTypeFolder) {\r\n                debug(`folder ${searchId} is not folder.`);\r\n                return false;\r\n            }\r\n            debug(JSON.stringify(file, null,  \"  \"));\r\n            if(file.id == root.id) {\r\n                paths.unshift({id: \"root\", name: \"\" });\r\n                break;\r\n            } else {\r\n                paths.unshift({id: file.id, name: file.name });\r\n            }\r\n            searchId = file.parents.shift();\r\n        }\r\n        debug(JSON.stringify(paths, null, \"  \"));\r\n        this._currentPath = paths;\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * Check the path is a directory.\r\n * @async\r\n * @param {GdfsPath} path A path to check\r\n * @returns {Promise<Boolean>} The path is a directory or not.\r\n */\r\nGdfs.prototype.isDirectory = async function(path) {\r\n    debug(\"No tests pass: Gdfs#isDirectory\");\r\n    const file = await this.getFileOfPath(this.toAbsolutePath(path));\r\n    if(!file) {\r\n        return false;\r\n    }\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Convert to absolute path.\r\n * @param {GdfsPath} path path to be converted\r\n * @returns {GdfsPath} An absolute path\r\n */\r\nGdfs.prototype.toAbsolutePath = function(path) {\r\n    debug(\"No tests pass: Gdfs#toAbsolutePath\");\r\n    if(path.isAbsolute()) {\r\n        return path;\r\n    }\r\n    const cwd = this.getCurrentPath();\r\n    return GdfsPath.merge(cwd, path);\r\n};\r\n\r\n/**\r\n * Read the directory to get a list of filenames.\r\n *\r\n * This method may not returns all files in the directory.\r\n * To know all files were listed, check the `pageToken` field in the parameter\r\n * `options` after the invocation.\r\n * If the reading was completed, the field would be set `null`.\r\n * The rest files unread will be returned at the next invocation with same\r\n * parameters.\r\n *\r\n * ```javascript\r\n * const readDirAll = async path => {\r\n *     const opts = { pageSize: 10, pageToken: null };\r\n *     const files = [];\r\n *     do {\r\n *        for(const fn of await files.readdir(path, opts)) {\r\n *            files.push(fn);\r\n *        }\r\n *     } while(opts.pageToken != null);\r\n * };\r\n * ```\r\n *\r\n * @async\r\n * @since v1.1.0\r\n * @param {string} path A path to the directory.\r\n *\r\n * @param {object|null} options (Optional) options for this method.\r\n *\r\n * Only two fields are available:\r\n *\r\n * * \"pageSize\": Set maximum array size that this method returns at one\r\n * time.  The default value 10 will be used if this is not specified or\r\n * zero or negative value is specified.\r\n * * \"pageToken\": Set null to initial invocation to read from first\r\n * entry. This would be updated other value if the unread files are\r\n * remained. The value is used for reading next files. User should not\r\n * set the value except for null.\r\n *\r\n * If this parameter is ommited, all files will be read.\r\n * This is not recomended feature for the directory that has a number of files.\r\n *\r\n * @returns {Promise<Array<string> >} returns an array of filenames.\r\n */\r\nGdfs.prototype.readdir = async function(path, options) {\r\n    path += path.match(/\\/$/) ? \"\" : \"/\";\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readdir: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n\r\n    if(!Gdfs.isFolder(parentFolder)) {\r\n        debug(`readdir: The path is not a folder ${path}`);\r\n        return null;\r\n    }\r\n\r\n    const files = [];\r\n    const readAll = (options == null);\r\n    options = options || {};\r\n    const pageSize = options.pageSize || 10;\r\n    const pageToken = options.pageToken || null;\r\n\r\n    const readFiles = async params => {\r\n        debug(`readdir: params: ${JSON.stringify(params, null, \"  \")}`);\r\n        const result = await Gdfs.getFileList(params);\r\n        debug(`readdir: result.nextPageToken: ${result.nextPageToken}`);\r\n        for(const file of result.files) {\r\n            files.push(file.name);\r\n        }\r\n        return result.nextPageToken;\r\n    };\r\n\r\n    const params = {\r\n        \"pageSize\": pageSize <= 0 ? 10 : pageSize,\r\n        \"pageToken\": pageToken,\r\n        \"q\": `parents in '${parentFolder.id}' and trashed = false`,\r\n        \"fields\": \"nextPageToken, files(name)\",\r\n    };\r\n\r\n    if(!readAll) {\r\n        options.pageToken = await readFiles(params);\r\n    } else {\r\n        do {\r\n            params.pageToken = await readFiles(params);\r\n        } while(params.pageToken != null);\r\n    }\r\n\r\n    debug(`readdir: files: ${JSON.stringify(files)}`);\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file's properties.\r\n * It is a file resource of Google Drive including id, name, mimeType,\r\n * webContentLink and webViewLink about the file or directory.\r\n *\r\n * @async\r\n * @param {string} path A pathname.\r\n * @returns {File} The file resource of Google Drive including id, name,\r\n *      mimeType, webContentLink and webViewLink about the file or directory.\r\n * @since v1.1.0\r\n */\r\nGdfs.prototype.stat = async function(path) {\r\n    debug(`Gdfs#stat(${path})`);\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    debug(`stat: absPath: ${absPath.toString()}`);\r\n    path = absPath.toString();\r\n    if(path === \"/\") {\r\n        const file = await Gdfs.getFileResource({\r\n            fileId: \"root\",\r\n            fields: \"id, name, mimeType, webContentLink, webViewLink\",\r\n        });\r\n        debug(`stat: file ${JSON.stringify(file)}`);\r\n        return file;\r\n    }\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`stat: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`stat: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`stat: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    if(files.length === 0) {\r\n        debug(`stat: File not found ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    debug(`stat: file ${JSON.stringify(file)}`);\r\n    return file;\r\n};\r\n\r\n/**\r\n * Read a file.\r\n * The file must have webContentLink in its resource to read the contents,\r\n * To get the resource, Use [`Gdfs#stat`](#stat).\r\n *\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<string>} The file content.\r\n */\r\nGdfs.prototype.readFile = async function(path) {\r\n    debug(`Gdfs#readFile(${path})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readFile: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`readFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`readFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`File not found ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(!file.webContentLink) {\r\n        debug(`File is not downloadable ${path}`);\r\n        return null;\r\n    }\r\n    return await Gdfs.downloadFile(file.id);\r\n};\r\n\r\n/**\r\n * Make a directory.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.mkdir = async function(path) {\r\n    debug(`mkdir(${path})`);\r\n\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`mkdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`mkdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`mkdir: pathname: ${pathname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, pathname);\r\n    debug(`mkdir: files: ${JSON.stringify(files)}`);\r\n    if(files.length > 0) {\r\n        debug(`mkdir: The directory exists ${path}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.createFile(\r\n        parentFolder.id, pathname, Gdfs.mimeTypeFolder);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Remove the directory but not a normal file.\r\n * The operation will fail, if it is not a directory nor empty.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.rmdir = async function(path) {\r\n    debug(`rmdir(${path})`);\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`rmdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`rmdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`rmdir: pathname: ${pathname}`);\r\n    if(pathname === \"\") {\r\n        debug(`rmdir: The root directory cannot be removed ${path}`);\r\n        return null;\r\n    }\r\n    const dires = await Gdfs.findFolderByName(parentFolder.id, pathname);\r\n    debug(`rmdir: dires: ${JSON.stringify(dires)}`);\r\n    if(dires.length === 0) {\r\n        debug(`rmdir: The directory not exists ${path}`);\r\n        return null;\r\n    }\r\n    const dir = dires.shift();\r\n    debug(`rmdir: dir ${JSON.stringify(dir)}`);\r\n    debug(`rmdir: _currentPath ${JSON.stringify(this._currentPath, null, \"  \")}`);\r\n    if(this._currentPath.filter(parent => parent.id == dir.id).length > 0 ||\r\n        dir.id === await Gdfs.getActualRootFolderId())\r\n    {\r\n        debug(`rmdir: The path is a parent ${path}`);\r\n        return null;\r\n    }\r\n    if(dir.mimeType !== Gdfs.mimeTypeFolder) {\r\n        debug(`rmdir: The path is not folder ${path}`);\r\n        return null;\r\n    }\r\n    const params = {\r\n        \"q\": `parents in '${dir.id}' and trashed = false`,\r\n        \"fields\": \"files(id)\",\r\n    };\r\n    debug(`rmdir: params ${JSON.stringify(params)}`);\r\n    const children = await Gdfs.getFileList(params);\r\n    debug(`rmdir: children: ${JSON.stringify(children, null, \"  \")}`);\r\n    if(children.files.length > 0) {\r\n        debug(`rmdir: The folder is not empty ${path}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete(\r\n        { fileId: dir.id });\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Delete the file but not directory.\r\n * This does not move the file to the trash-box.\r\n *\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.unlink = async function(path) {\r\n    debug(`unlink(${path})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`unlink: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`unlink: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const pathname = absPath.getFilename();\r\n    debug(`unlink: pathname: ${pathname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, pathname);\r\n    debug(`unlink: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`unlink: The file not exists ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`unlink: The file is a folder ${path}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete({ fileId: file.id });\r\n    const result = response.result;\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Write a file.\r\n * @async\r\n * @param {string} path A pathname to operate.\r\n * @param {string} mimeType A mimeType of the file content.\r\n * @param {string} data A file content.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.writeFile = async function(path, mimeType, data) {\r\n    debug(`Gdfs#writeFile(${path},${mimeType}, ${JSON.stringify(data)})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`writeFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`writeFile: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`writeFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`writeFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        const file = await Gdfs.createFile(\r\n            parentFolder.id, filename, mimeType);\r\n        const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n        if(parentFolder.id === this.getCurrentFolderId()) {\r\n            await this.fireCwdUpdate();\r\n        }\r\n        return result;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`writeFile: The path already exists as directory ${path}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\nmodule.exports = Gdfs;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs-ui\");\r\ndebug(\"loading\");\r\nconst Gdfs = require(\"./gdfs.js\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\n\r\n/**\r\n * class GdfsUi\r\n * @constructor\r\n * @param {HTMLElement} The root element that UI widget will be built.\r\n * @param {Gdfs} The gapi client.\r\n */\r\nfunction GdfsUi(element, opt) {\r\n    debug(\"Start of GdfsUi ctor\");\r\n    this._element = element;\r\n    this._gdfs = new Gdfs();\r\n    this._pageSize = 10;\r\n    this._trashed = false;\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    this._opt = {\r\n        onFileListChange: () => {},\r\n        onCurrentDirChange: () => {},\r\n    };\r\n\r\n    opt = opt || {};\r\n    for(const key of Object.keys(this._opt)) {\r\n        if(key in opt) {\r\n            this._opt[key] = opt[key];\r\n        }\r\n    }\r\n\r\n    // events\r\n    this._fileListChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-filelist-change\");\r\n    this._currentDirChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-current-dir-change\");\r\n\r\n    this._currentDirChangeEvent.listen(\r\n        this._opt.onCurrentDirChange);\r\n    this._fileListChangeEvent.listen(\r\n        this._opt.onFileListChange);\r\n\r\n    this._gdfs.onCwdUpdate(async () => {\r\n        debug(\"Start of _gdfs.onCwdUpdate\");\r\n        await this.reload();\r\n        this._currentDirChangeEvent.fire();\r\n        debug(\"End of _gdfs.onCwdUpdate\");\r\n    });\r\n\r\n    const onSignedInStatusChange = async status => {\r\n        debug(\"Start of signInStatusChange\");\r\n        if(status) {\r\n            await this._gdfs.chdir(\"/\");\r\n        }\r\n        debug(\"End of signInStatusChange\");\r\n    };\r\n\r\n    // Listen events\r\n    Gdfs.signInStatusChangeEvent.listen(\r\n        () => onSignedInStatusChange(Gdfs.isSignedIn()));\r\n\r\n    onSignedInStatusChange(Gdfs.isSignedIn());\r\n    debug(\"End of GdfsUi ctor\");\r\n}\r\n\r\n/**\r\n * Returns the listing files in current directory is completed.\r\n * @returns {boolean} true if the listing files is completed.\r\n */\r\nGdfsUi.prototype.isPageCompleted = function() {\r\n    const status = this._pageToken == null;\r\n    return status;\r\n};\r\n\r\n/**\r\n * Get current path as full path.\r\n * @returns {Array<string>} The array of file ids.\r\n */\r\nGdfsUi.prototype.getCurrentPath = function() {\r\n    return this._gdfs._currentPath;\r\n};\r\n\r\n/**\r\n * Get files list on current page.\r\n * @param {number} begin a file index\r\n * @param {number} end a file index\r\n * @returns {Array<File>} the files in current page.\r\n */\r\nGdfsUi.prototype.getFiles = async function(begin, end) {\r\n    debug(`GdfsUi#getFiles param:{begin:${begin}, end:${end})}`);\r\n    debug(`_pageToken: ${this._pageToken}`);\r\n    if(this._pageToken == null) {\r\n        this._files = [];\r\n    }\r\n    while(end > this._files.length) {\r\n        await this.readDir();\r\n        this._fileListChangeEvent.fire();\r\n        if(this._pageToken == null) {\r\n            break;\r\n        }\r\n    }\r\n    return this._files.slice(begin, end);\r\n};\r\n\r\n/**\r\n * Read the files on current directory.\r\n * @async\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.readDir = async function() {\r\n\r\n    const andConditionsOfQuerySearchClauses = [\r\n        `parents in '${this._gdfs.getCurrentFolderId()}'`,\r\n        `trashed = ${this._trashed?\"true\":\"false\"}`,\r\n    ];\r\n\r\n    const queryParameters = {\r\n        \"pageSize\": this._pageSize,\r\n        \"pageToken\": this._pageToken,\r\n        \"q\": andConditionsOfQuerySearchClauses.join(\" and \"),\r\n        \"fields\": \"nextPageToken, files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    const result = await Gdfs.getFileList(queryParameters);\r\n    this._pageToken = result.nextPageToken;\r\n    for(const file of result.files) {\r\n        this._files.push(file);\r\n    }\r\n};\r\n\r\n/**\r\n * Reload the file list.\r\n * @async\r\n * @returns {Promise} to sync\r\n */\r\nGdfsUi.prototype.reload = async function() {\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    await this.readDir();\r\n    this._fileListChangeEvent.fire();\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @param {string} folderId A destination file id to move.\r\n * To move to parent, \"..\" is available.\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.chdirById = async function(folderId) {\r\n    await this._gdfs.chdirById(folderId);\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {string} fileId The file id of the target file.\r\n * @returns {Promise<object>} The resource object.\r\n */\r\nGdfsUi.prototype.getFileResource = async function(fileId) {\r\n    return await Gdfs.getFileResource({\r\n        \"fileId\": fileId,\r\n    });\r\n};\r\n\r\n/**\r\n * Upload a file.\r\n * @param {File} file the file to be uploaded.\r\n * @return {Promise<File>} an uploaded File.\r\n */\r\nGdfsUi.prototype.uploadFile = function (file) {\r\n    return new Promise( (resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n            resolve(await this.writeFile(\r\n                file.name, file.type, reader.result));\r\n        };\r\n        reader.onerror = event => {\r\n            reject(new Error([\r\n                \"Fail to upload. Could not read the file \",\r\n                `${file.name}(${event.type}).`,\r\n            ].join(\"\")));\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n};\r\n\r\n/**\r\n * Create or overwrite a file to current directory.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The content type.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of update.\r\n */\r\nGdfsUi.prototype.writeFile = async function (\r\n    filename, mimeType, data)\r\n{\r\n    // Find same file in current directory\r\n    const fileIds = this._files\r\n        .filter(file => (file.name === filename))\r\n        .map( file => file.id );\r\n\r\n    if(fileIds.length == 0) {\r\n        //Create new file\r\n        const response = await Gdfs.createFile(\r\n            this._gdfs.getCurrentFolderId(), filename, mimeType);\r\n        const file = JSON.parse(response);\r\n        return await Gdfs.updateFile(\r\n            file.id, mimeType, data);\r\n    }\r\n\r\n    // Overwrite the file\r\n    return await Gdfs.updateFile(\r\n        fileIds[0], mimeType, data);\r\n};\r\n\r\nmodule.exports = GdfsUi;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdrive-fs\");\r\nconst Gdfs = require(\"./lib/gdfs.js\");\r\nGdfs.Ui = require(\"./lib/gdfs-ui.js\");\r\nGdfs.Path = require(\"./lib/gdfs-path.js\");\r\ntry {\r\n    const context = (Function(\"return this;\"))();\r\n    if(context === window) {\r\n        window.Gdfs = Gdfs;\r\n    }\r\n} catch(err) {\r\n    debug(err.message);\r\n}\r\nmodule.exports = Gdfs;\r\n"]}