{"version":3,"sources":["node_modules/ms/index.js","node_modules/debug/src/debug.js","node_modules/process/browser.js","node_modules/debug/src/browser.js","lib/gdfs-event.js","lib/gdfs-path.js","lib/gdfs.js","lib/gdfs-ui.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","useColors","window","type","navigator","userAgent","toLowerCase","match","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","parseInt","RegExp","$1","formatArgs","namespace","humanize","diff","c","color","splice","index","lastC","replace","log","Function","save","namespaces","storage","removeItem","debug","load","r","localstorage","localStorage","require","chrome","local","colors","formatters","j","v","JSON","stringify","err","message","enable","GdfsEvent","target","eventName","_target","_eventName","listen","handler","constructor","addEventListener","event","fire","extraData","Event","key","Object","keys","dispatchEvent","GdfsPath","pathname","_lastSlash","_absolute","_paths","undefined","parse","getPathPart","toString","paths","elements","join","getFilename","pop","map","item","unshift","merge","p","reduce","pathA","pathB","a","b","isAbsolute","joined","split_path","escaped","element","chars","split","lastSlash","absolute","shift","replacement","acc","next","isArray","last","isDirSpec","rootSpec","dirSpec","Gdfs","_oncwdupdate","_currentPath","id","createClient","signInStatusChangeEvent","loadApi","clientId","apiKey","script","createElement","setAttribute","Promise","resolve","reject","onload","gapi","client","init","discoveryDocs","scope","auth2","getAuthInstance","isSignedIn","readyState","onerror","URIError","src","body","appendChild","mimeTypeFolder","get","signIn","signOut","getFileList","response","drive","files","list","queryParameters","result","findFolderByName","parentFolderId","folderName","folders","params","q","file","pageToken","nextPageToken","stack","findFileByName","fileName","getFileResource","parameters","isFolder","mimeType","downloadFile","fileId","acknowledgeAbuse","requestWithAuth","alt","createFile","folderId","filename","parents","updateFile","data","uploadType","method","endpoint","queryParams","headers","xhr","XMLHttpRequest","open","createUrl","forEach","setRequestHeader","getAccessToken","responseText","statusText","ontimeout","send","accessToken","currentUser","getAuthResponse","access_token","filter","value","encodeURI","getActualRootFolderId","res","fields","onCwdUpdate","prev","fireCwdUpdate","getCurrentFolderId","slice","getCurrentPath","path","setCurrentPath","isDirectory","getPaths","parent","children","child","getFileOfPath","next_cwd","chdirById","currentFolderId","root","searchId","toAbsolutePath","readdir","options","absPath","parentFolder","readAll","pageSize","readFiles","stat","readFile","webContentLink","mkdir","dirname","rmdir","dires","delete","unlink","writeFile","GdfsUi","opt","_element","_gdfs","_pageSize","_trashed","_pageToken","_files","_opt","onFileListChange","onCurrentDirChange","_fileListChangeEvent","_currentDirChangeEvent","reload","onSignedInStatusChange","status","isPageCompleted","getFiles","begin","end","readDir","andConditionsOfQuerySearchClauses","uploadFile","reader","FileReader","readAsArrayBuffer","fileIds","Ui","Path"],"mappings":"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","file":"gdrive-fs.min.map","sourceRoot":"..","sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsEvent\");\r\n/**\r\n * Event class\r\n * @constructor\r\n * @param {HTMLElement} target An element that dispatch\r\n * @param {string} eventName An event name\r\n */\r\nfunction GdfsEvent(target, eventName) {\r\n    this._target = target;\r\n    this._eventName = eventName;\r\n}\r\n\r\n/**\r\n * Listen this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.listen = function(handler) {\r\n    debug(`GdfsEvent.listen: ${this._eventName}=>${handler.constructor.name}`);\r\n    if(handler.constructor.name === \"AsyncFunction\") {\r\n        this._target.addEventListener(\r\n            this._eventName, async event => await handler(event));\r\n    } else {\r\n        this._target.addEventListener(\r\n            this._eventName, handler);\r\n    }\r\n};\r\n\r\n/**\r\n * Fire this event.\r\n * @param {Function} handler An event handler\r\n * @returns {undefined}\r\n */\r\nGdfsEvent.prototype.fire = function(extraData = {}) {\r\n    const event = new Event(this._eventName);\r\n    for(const key of Object.keys(extraData)) {\r\n        event[key] = extraData[key];\r\n    }\r\n    debug(\r\n        `GdfsEvent.fire: ${this._eventName}`,\r\n        `extraData: ${JSON.stringify(extraData)}`);\r\n    this._target.dispatchEvent(event);\r\n};\r\n\r\nmodule.exports = GdfsEvent;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"GdfsPath\");\r\ndebug(\"loading\");\r\n\r\n/**\r\n * Gdfs Path class.\r\n * @constructor\r\n * @param {string|undefined} pathname initial path.\r\n */\r\nfunction GdfsPath(pathname) {\r\n    this._lastSlash = true;\r\n    this._absolute = true;\r\n    this._paths = [];\r\n    if(pathname != undefined) {\r\n        this.parse(pathname);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Get a part of path.\r\n * @returns {GdfsPath} A path object including only path.\r\n */\r\nGdfsPath.prototype.getPathPart = function() {\r\n    if(this._lastSlash) {\r\n        return new GdfsPath(this.toString());\r\n    }\r\n    const paths = this.elements();\r\n    paths.splice(-1, 1, \"\");\r\n    debug(`getPathPart: paths: ${JSON.stringify(paths)}`);\r\n    return new GdfsPath(paths.join(\"/\"));\r\n};\r\n\r\n/**\r\n * Get filename part of path.\r\n * @returns {string} A filename.\r\n */\r\nGdfsPath.prototype.getFilename = function() {\r\n    return this.elements().pop();\r\n};\r\n\r\n/**\r\n * Get paths elements.\r\n * @returns {Array<string>} the elements.\r\n */\r\nGdfsPath.prototype.elements = function() {\r\n    const elements = this._paths.map(item => item);\r\n    if(this._absolute) {\r\n        elements.unshift(\"\");\r\n    }\r\n    if(this._lastSlash) {\r\n        elements.push(\"\");\r\n    }\r\n    return elements;\r\n};\r\n\r\n/**\r\n * Create a new path object with joining the two paths.\r\n * \r\n * @param {Array<GdfsPath>} paths The paths to join.\r\n * @returns {GdfsPath} The path that was joined.\r\n */\r\nGdfsPath.merge = (...paths) => {\r\n    debug(`Gdfs.merge: ${paths.map(p=>p.toString()).join(\" | \")}`);\r\n    return paths.reduce( (pathA, pathB, index) => {\r\n        debug(`Gdfs.merge: Reducing #${index}`);\r\n        debug(`Gdfs.merge: pathA: ${pathA.toString()}`);\r\n        debug(`Gdfs.merge: pathB: ${pathB.toString()}`);\r\n        if(typeof(pathA) === \"string\") {\r\n            pathA = new GdfsPath(pathA);\r\n        }\r\n        if(typeof(pathB) === \"string\") {\r\n            pathB = new GdfsPath(pathB);\r\n        }\r\n        const a = pathA.toString();\r\n        const b = pathB.toString();\r\n        if(pathB.isAbsolute()) {\r\n            debug(`returns ${b}`);\r\n            return new GdfsPath(b);\r\n        }\r\n        const joined = new GdfsPath([a, b].join(\"/\"));\r\n        debug(`Gdfs.merge: returns ${joined.toString()}`);\r\n        return joined;\r\n    });\r\n};\r\n\r\nconst split_path = pathname => {\r\n    const paths = [];\r\n    let escaped = false;\r\n    let i = 0;\r\n    let element = \"\";\r\n    let chars = pathname.split(\"\");\r\n    while(i < chars.length) {\r\n        const c = chars[i];\r\n        if(escaped) {\r\n            element += c;\r\n            escaped = false;\r\n        } else if(c === \"\\\\\"){\r\n            escaped = true;\r\n        } else if(c === \"/\") {\r\n            paths.push(element);\r\n            element = \"\";\r\n        } else {\r\n            element += c;\r\n        }\r\n        i++;\r\n    }\r\n    paths.push(element);\r\n    if(escaped) {\r\n        throw new Error(`Invalid pathname ${pathname}`);\r\n    }\r\n    if(paths.length == 0) {\r\n        throw new Error(\"Invalid pathname. It should not be empty.\");\r\n    }\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Set a path repersented by a string.\r\n * @param {string} pathname A path name to parse\r\n * @return {undefined}\r\n */\r\nGdfsPath.prototype.parse = function(pathname) {\r\n    let paths = split_path(pathname.replace(/\\/+/g, \"/\"));\r\n    debug(`parse ${JSON.stringify(pathname)} => ${JSON.stringify(paths)}`);\r\n    const lastSlash = (paths[paths.length - 1] === \"\");\r\n    const absolute = (paths[0] === \"\");\r\n    if(lastSlash) {\r\n        paths.pop();\r\n    }\r\n    if(absolute) {\r\n        paths.shift();\r\n    }\r\n    this._lastSlash = !!lastSlash;\r\n    this._absolute = !!absolute;\r\n    for(;;) {\r\n        let replacement = false;\r\n        if(paths.length >= 2) {\r\n            paths = paths.reduce( (acc, next) => {\r\n                if(!Array.isArray(acc)) {\r\n                    acc = [acc];\r\n                }\r\n                const last = acc[acc.length - 1];\r\n                if(last !== \"..\" && next === \"..\") {\r\n                    acc.pop();\r\n                    replacement = true;\r\n                } else if(last !== \".\" && next === \".\") {\r\n                    replacement = true;\r\n                } else {\r\n                    acc.push(next);\r\n                }\r\n                return acc;\r\n            });\r\n        }\r\n        if(!replacement) {\r\n            this._paths = paths;\r\n            debug(`this._paths:${JSON.stringify(this._paths)}`);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns if this represents an absolute path.\r\n * @returns {Boolean} True if this represents an absolute path, otherwise false.\r\n */\r\nGdfsPath.prototype.isAbsolute = function() {\r\n    return this._absolute;\r\n};\r\n\r\n/**\r\n * Returns if this represents a directory.\r\n * @returns {Boolean} True if this represents a directory, otherwise false.\r\n */\r\nGdfsPath.prototype.isDirSpec = function() {\r\n    return this._lastSlash;\r\n};\r\n\r\n/**\r\n * Returns a path represented by string.\r\n * @returns {string} The path that this is representing.\r\n */\r\nGdfsPath.prototype.toString = function() {\r\n    if(this._paths.length === 0) {\r\n        return \"/\";\r\n    }\r\n    const rootSpec = this._absolute ? \"/\" : \"\";\r\n    const dirSpec = this._lastSlash ? \"/\" : \"\";\r\n    const pathname = `${rootSpec}${this._paths.join(\"/\")}${dirSpec}`;\r\n    return pathname;\r\n};\r\n\r\nmodule.exports = GdfsPath;\r\n","/*global gapi:false*/\r\n\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs\");\r\ndebug(\"loading\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\nconst GdfsPath = require(\"./gdfs-path.js\");\r\n\r\n/**\r\n * Gdfs class is an interface for the Google Drive API v3.\r\n *\r\n * The instance manages a current working directory(CWD) and offers methods\r\n * to operate files and folders on the Google Drive by its pathname.\r\n *\r\n * Before creating an instance, the APIs must be loaded by the class method\r\n * [`loadApi`](#.loadApi) with a ClientId and ApiKey.\r\n * These had to be created in a project of Google devloper Console.\r\n *\r\n * And to operates files, user must sign-in with the Google account.\r\n * See [signIn](#.signIn) and [signOut](#.signOut).\r\n *\r\n * Instance's CWD is initialized to the root on constructor. It can be changed\r\n * by [chdir](#chdir) method. When it is changed, the 'oncwdupdate' callback\r\n * is fired. To know where the CWD is, The [cwd](#cwd) method is available.\r\n *\r\n * For details of file operations, see the document of each methods:\r\n *\r\n * * [readdir](#readdir)\r\n * * [stat](#stat)\r\n * * [readFile](#readFile)\r\n * * [writeFile](#writeFile)\r\n * * [unlink](#unlink)\r\n * * [mkdir](#mkdir)\r\n * * [rmdir](#rmdir) ... and so on.\r\n *\r\n * @constructor\r\n */\r\nfunction Gdfs() {\r\n    this._oncwdupdate = null;\r\n    this._currentPath = [{ id: \"root\", name: \"\", }];\r\n}\r\n\r\n/**\r\n * Create Gdfs client.\r\n * @returns {Gdfs} The google drive interface that has a current directory.\r\n */\r\nGdfs.createClient = () => {\r\n    return new Gdfs();\r\n};\r\n\r\n/**\r\n * signInStatusChangeEvent\r\n * @type {GdfsEvent}\r\n */\r\nGdfs.signInStatusChangeEvent = new GdfsEvent(\r\n    window, \"gdfs-signin-status-change\");\r\n\r\n/**\r\n * Load Google Drive APIs and initialize its client object.\r\n *\r\n * The loaded all APIs are accessible with a global `gapi` object.\r\n * But it is wrapped by this class so the users should not use it directly.\r\n *\r\n * @param {string} clientId A clientId from the Developer console.\r\n * @param {string} apiKey An apiKey from the Developer console.\r\n * @returns {Promise} A promise that will be resolved when the loading completed.\r\n */\r\nGdfs.loadApi = (clientId, apiKey) => {\r\n    debug(\"Start of Gdfs.loadApi\");\r\n    const script = document.createElement(\"SCRIPT\");\r\n    script.setAttribute(\"async\", \"async\");\r\n    script.setAttribute(\"src\", \"https://apis.google.com/js/api.js\");\r\n    const p = new Promise( (resolve, reject) => {\r\n        script.addEventListener(\"load\", () => {\r\n            script.onload = () => {};\r\n            gapi.load(\"client:auth2\", async () => {\r\n                debug(\"initialize gapi.client\");\r\n\r\n                if(typeof(clientId) === \"object\" && apiKey == null &&\r\n                    \"clientId\" in clientId && \"apiKey\" in clientId &&\r\n                    \"discoveryDocs\" in clientId && \"scope\" in clientId)\r\n                {\r\n                    await gapi.client.init(clientId);\r\n                } else {\r\n                    await gapi.client.init({\r\n                        clientId: clientId, apiKey: apiKey,\r\n                        discoveryDocs: [\r\n                            \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\r\n                        ],\r\n                        scope: [\r\n                            \"https://www.googleapis.com/auth/drive\",\r\n                            \"https://www.googleapis.com/auth/drive.appdata\",\r\n                            \"https://www.googleapis.com/auth/drive.file\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata\",\r\n                            \"https://www.googleapis.com/auth/drive.metadata.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.photos.readonly\",\r\n                            \"https://www.googleapis.com/auth/drive.readonly\",\r\n                        ].join(\" \"),\r\n                    });\r\n                }\r\n                gapi.auth2.getAuthInstance().isSignedIn.listen( () => {\r\n                    debug(\"the signed-in-status changed\");\r\n                    Gdfs.signInStatusChangeEvent.fire();\r\n                });\r\n                Gdfs.signInStatusChangeEvent.fire();\r\n                debug(`Gdfs.loadApi SignedIn: ${Gdfs.isSignedIn()}`);\r\n                debug(\"Gdfs.loadApi is resolved\");\r\n                resolve();\r\n            });\r\n        });\r\n        script.addEventListener(\"readystatechange\", () => {\r\n            debug(`readystatechange ${script.readyState}`);\r\n            if(script.readyState === \"complete\") {\r\n                script.onload();\r\n            }\r\n        });\r\n        script.onerror = event => {\r\n            debug(\"Gdfs.loadApi is rejected\");\r\n            reject(new URIError(\r\n                `The script ${event.target.src} is not accessible.`));\r\n        };\r\n        document.body.appendChild(script);\r\n    });\r\n    debug(\"End of Gdfs.loadApi\");\r\n    return p;\r\n};\r\n\r\n/**\r\n * A mime type of the Google Drive's folder.\r\n * @type {string}\r\n */\r\nGdfs.mimeTypeFolder = \"application/vnd.google-apps.folder\";\r\n\r\n/**\r\n * Check if gapi was signed in.\r\n * @returns {boolean} true if gapi is signed in, otherwise false.\r\n */\r\nGdfs.isSignedIn = () => {\r\n    return gapi.auth2.getAuthInstance().isSignedIn.get();\r\n};\r\n\r\n/**\r\n * Sign in to Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signIn = async () => {\r\n    return await gapi.auth2.getAuthInstance().signIn();\r\n};\r\n\r\n/**\r\n * Sign out from the Google Drive.\r\n * @async\r\n * @returns {undefined}\r\n */\r\nGdfs.signOut = async () => {\r\n    return await gapi.auth2.getAuthInstance().signOut();\r\n};\r\n\r\n/**\r\n * Get file list.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileList = async (queryParameters) => {\r\n    const response = await gapi.client.drive.files.list(queryParameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Find a folder by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} folderName A folder name to find\r\n * @returns {Array<object>} A folder list that found.\r\n */\r\nGdfs.findFolderByName = async (parentFolderId, folderName) => {\r\n    debug(\"No tests pass: Gdfs.findFolderByName\");\r\n\r\n    const folders = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${folderName}'`,\r\n        `mimeType = '${Gdfs.mimeTypeFolder}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`${JSON.stringify(params)}`);\r\n    try {\r\n        do {\r\n            const result = await Gdfs.getFileList(params);\r\n            debug(`${JSON.stringify(result)}`);\r\n            for(const file of result.files) {\r\n                folders.push(file);\r\n            }\r\n            params.pageToken = result.nextPageToken;\r\n        } while(params.pageToken != null);\r\n    } catch(err) {\r\n        debug(err.stack);\r\n    }\r\n\r\n    return folders;\r\n};\r\n\r\n/**\r\n * Find a file by name from a folder.\r\n * @async\r\n * @param {string} parentFolderId A parent folder id.\r\n * @param {string} fileName A file name to find\r\n * @returns {Promise<Array<object> >} A folder list that found.\r\n */\r\nGdfs.findFileByName = async (parentFolderId, fileName) => {\r\n    debug(\"No tests pass: Gdfs.findFileByName\");\r\n\r\n    const files = [];\r\n    const q = [\r\n        `parents in '${parentFolderId}'`,\r\n        `name = '${fileName}'`,\r\n        \"trashed = false\",\r\n    ].join(\" and \");\r\n\r\n    const params = {\r\n        \"pageSize\": 10,\r\n        \"pageToken\": null,\r\n        \"q\": q,\r\n        \"fields\": \"nextPageToken, \" +\r\n                  \"files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    debug(`findFileByName: params: ${JSON.stringify(params, null, \"  \")}`);\r\n    do {\r\n        const result = await Gdfs.getFileList(params);\r\n        for(const file of result.files) {\r\n            debug(`findFileByName: found file: ${JSON.stringify(file)}`);\r\n            files.push(file);\r\n        }\r\n        debug(`findFileByName: result.nextPageToken: ${result.nextPageToken}`);\r\n        params.pageToken = result.nextPageToken;\r\n    } while(params.pageToken != null);\r\n\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {object} queryParameters The parameters for the API.\r\n * @returns {Promise<object>} The result of the API.\r\n */\r\nGdfs.getFileResource = async (parameters) => {\r\n    const response = await gapi.client.drive.files.get(parameters);\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Check if the file is a folder.\r\n * @param {object} file The file object provided from the result\r\n * of `getFileList` method.\r\n * @returns {boolean} The file is a folder or not.\r\n */\r\nGdfs.isFolder = (file) => {\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Get a file content as text from Google Drive.\r\n * Even if the file is not a text actually, it could be converted\r\n * to ArrayBuffer, Blob or JSON to use by Web App.\r\n * @param {string} fileId The file id to download.\r\n * @param {boolean|null} acknowledgeAbuse A user acknowledgment\r\n * status for the potential to abuse. This parameter is optional.\r\n * default value is false.\r\n * @returns {Promise<string>} A downloaded content as text.\r\n */\r\nGdfs.downloadFile = (fileId, acknowledgeAbuse) => {\r\n    return requestWithAuth(\"GET\",\r\n        \"https://www.googleapis.com/drive/v3/files/\"+fileId,\r\n        { alt: \"media\", acknowledgeAbuse : acknowledgeAbuse });\r\n};\r\n\r\n/**\r\n * Create a new file's resource.\r\n * @param {string} folderId The folder id where the file is created.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The mime type for the new file.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.createFile = async (folderId, filename, mimeType) => {\r\n    const response = await requestWithAuth(\"POST\",\r\n        \"https://www.googleapis.com/drive/v3/files\", {},\r\n        { \"Content-Type\": \"application/json\", },\r\n        JSON.stringify({\r\n            name: filename,\r\n            mimeType: mimeType,\r\n            parents: [folderId],\r\n        }));\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * Upload a file content to update a existing file.\r\n * @param {string} fileId The file id to update.\r\n * @param {string} mimeType The content type of the file.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of the API.\r\n */\r\nGdfs.updateFile = async (fileId, mimeType, data) => {\r\n    const response = await requestWithAuth(\"PATCH\",\r\n        \"https://www.googleapis.com/upload/drive/v3/files/\"+fileId,\r\n        { uploadType: \"media\" },\r\n        { \"Content-Type\": mimeType },\r\n        data);\r\n    return JSON.parse(response);\r\n};\r\n\r\n/**\r\n * @param {string} method The request method.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object} queryParams The query parameters.\r\n * @param {object} headers The request headers.\r\n * @param {any} body The request body.\r\n * @returns {Promise<object>} The response of the request.\r\n */\r\nconst requestWithAuth = (method, endpoint, queryParams, headers, body) => {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open(method, createUrl(endpoint, queryParams), true);\r\n    headers = headers || {};\r\n    Object.keys(headers).forEach( name => {\r\n        xhr.setRequestHeader(name, headers[name]);\r\n    });\r\n    xhr.setRequestHeader(\"Authorization\",\r\n        \"Bearer \" + getAccessToken());\r\n    xhr.timeout = 30000;\r\n    return new Promise( (resolve, reject) => {\r\n        xhr.onload = () => { resolve(xhr.responseText); };\r\n        xhr.onerror = () => { reject(new Error(xhr.statusText)); };\r\n        xhr.ontimeout = () => { reject(new Error(\"request timeout\")); };\r\n        xhr.send(body);\r\n    });\r\n};\r\n\r\n/**\r\n * Get access-token on current session.\r\n * @returns {string} The access token.\r\n */\r\nconst getAccessToken = () => {\r\n    const googleUser = gapi.auth2.getAuthInstance().currentUser.get();\r\n    const authResponse = googleUser.getAuthResponse(true);\r\n    const accessToken = authResponse.access_token;\r\n    return accessToken;\r\n};\r\n\r\n/**\r\n * Create URI including query parameters.\r\n * @param {string} endpoint The endpoint of API.\r\n * @param {object|null} params The query parameters.\r\n * @returns {string} The URI.\r\n */\r\nconst createUrl = (endpoint, params) => {\r\n    if(params == null) {\r\n        return endpoint;\r\n    }\r\n    let keys = Object.keys(params).filter(\r\n        key => (key !== \"\"));\r\n    if(keys.length == 0) {\r\n        return endpoint;\r\n    }\r\n    let queryString = keys.map( key => {\r\n        let value = params[key];\r\n        return (value == null ? null : `${key}=${encodeURI(value)}`);\r\n    }).join(\"&\");\r\n    return `${endpoint}?${queryString}`;\r\n};\r\n\r\n/**\r\n * Get actual root folder id.\r\n * @async\r\n * @return {Promise<string>} The root folder's id\r\n */\r\nGdfs.getActualRootFolderId = async () => {\r\n    const res = await Gdfs.getFileResource({ fileId: \"root\", fields: \"id\" });\r\n    debug(`getActualRootFolderId: res ${JSON.stringify(res, null, \"  \")}`);\r\n    return res.id;\r\n};\r\n\r\n/**\r\n * Set oncwdchage callback hander.\r\n * @param {FUnction|AsyncFunction} handler a function to be invoked when\r\n *      the current directory is changed.\r\n * @returns {undefined|Function} the previous handler will be returned.\r\n */\r\nGdfs.prototype.onCwdUpdate = function(handler) {\r\n    const prev = this._oncwdupdate;\r\n    if(handler != null) {\r\n        this._oncwdupdate = handler;\r\n    }\r\n    return prev;\r\n};\r\n\r\n/**\r\n * Fire cwdUpdate.\r\n * @returns {Promise} what the handler returns.\r\n */\r\nGdfs.prototype.fireCwdUpdate = async function() {\r\n    if(this._oncwdupdate) {\r\n        try {\r\n            const result = this._oncwdupdate();\r\n            if(result != null) {\r\n                if(result.constructor === Promise) {\r\n                    return await result;\r\n                }\r\n                return result;\r\n            }\r\n        } catch (err) {\r\n            debug(err.stack);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Get current folder id.\r\n * @returns {string} The folder id that the instance is.\r\n */\r\nGdfs.prototype.getCurrentFolderId = function() {\r\n    return this._currentPath.slice(-1)[0].id;\r\n};\r\n\r\n/**\r\n * Get current working directory as path object.\r\n * @returns {GdfsPath} the current working directory.\r\n */\r\nGdfs.prototype.getCurrentPath = function() {\r\n    const path = this._currentPath.map( path => `${path.name}/`).join(\"\");\r\n    const cwd = new GdfsPath(path);\r\n    debug(`getCurrentPath: ${cwd.toString()}`);\r\n    return cwd;\r\n};\r\n\r\n/**\r\n * Set current working directory with path object.\r\n * @async\r\n * @param {GdfsPath} path the new current working directory.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.setCurrentPath = async function(path) {\r\n    debug(\"No tests pass: Gdfs#setCurrentPath\");\r\n    debug(`setCurrentPath(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(`The path must be absolute. ${path}`);\r\n        return false;\r\n    }\r\n    if(!(await this.isDirectory(path))) {\r\n        debug(`${path} is not a directory`);\r\n        return false;\r\n    }\r\n    this._currentPath = await this.getPaths(path);\r\n    await this.fireCwdUpdate();\r\n    return true;\r\n};\r\n\r\n/**\r\n * Get an array of path element from root directory.\r\n * @async\r\n * @param {GdfsPath} path path object.\r\n * @returns {Promise<Array<object> >} the array of the object having an id and\r\n *      the name.\r\n */\r\nGdfs.prototype.getPaths = async function(path) {\r\n    debug(\"No tests pass: Gdfs#getPaths\");\r\n    debug(`getPaths(${path})`);\r\n    if(!path.isAbsolute()) {\r\n        debug(\"getPaths: Error: the path must be absolute\");\r\n        return null;\r\n    }\r\n    const paths = [ { id:\"root\", name:\"\", mimeType: Gdfs.mimeTypeFolder } ];\r\n    for(const name of path.elements().slice(1)) {\r\n        if(name === \"\") {\r\n            break;\r\n        }\r\n        const parent = paths.slice(-1)[0];\r\n        debug(`name: ${name}, parent: ${JSON.stringify(parent)}`);\r\n        const path = { id: null, name: null, mimeType: null };\r\n        if(parent.id != null) {\r\n            const children = await Gdfs.findFileByName(parent.id, name);\r\n            if(children.length > 0) {\r\n                const child = children.shift();\r\n                path.id = child.id;\r\n                path.name = child.name;\r\n                path.mimeType = child.mimeType;\r\n            }\r\n        }\r\n        paths.push(path);\r\n    }\r\n    debug(`getPaths: ${JSON.stringify(paths, null, \"  \")}`);\r\n    return paths;\r\n};\r\n\r\n/**\r\n * Get the file object that the path points to.\r\n * @param {GdfsPath} path the path.\r\n * @returns {file} the file object of google drive.\r\n */\r\nGdfs.prototype.getFileOfPath = async function(path) {\r\n    const paths = await this.getPaths(path);\r\n    if(!paths) {\r\n        return null;\r\n    }\r\n    return paths.slice(-1)[0];\r\n};\r\n\r\n/**\r\n * Get the current working directory of gdrive-fs.\r\n * @returns {string} The current working directory.\r\n */\r\nGdfs.prototype.cwd = function() {\r\n    return this.getCurrentPath().toString();\r\n};\r\n\r\n/**\r\n * Change or move the current working directory to the path.\r\n * @param {string} pathname A pathname to operate.\r\n * @async\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdir = async function(pathname) {\r\n    debug(\"No tests pass: Gdfs#chdir\");\r\n    const cwd = this.getCurrentPath();\r\n    const next_cwd = GdfsPath.merge(cwd, new GdfsPath(pathname));\r\n    return await this.setCurrentPath(next_cwd);\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @async\r\n * @param {string} folderId A destination file id to move.\r\n *      To move to parent, \"..\" is available.\r\n * @returns {Promise<boolean>} the status of the operation.\r\n */\r\nGdfs.prototype.chdirById = async function(folderId) {\r\n    debug(`Gdfs.chdirById( ${folderId} )`);\r\n    if(folderId === \".\") {\r\n        return true;\r\n    }\r\n    const currentFolderId = this.getCurrentFolderId();\r\n    if(folderId === \"/\" || folderId === \"root\" ) {\r\n        this._currentPath = [ { id:\"root\", name:\"\" } ];\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId === \"..\") {\r\n        if(currentFolderId === \"root\") {\r\n            debug(\"Could not move to upper folder from root.\");\r\n            return false;\r\n        }\r\n        this._currentPath.pop();\r\n        await this.fireCwdUpdate();\r\n    } else if(folderId !== currentFolderId) {\r\n        const paths = [];\r\n        const root = await Gdfs.getFileResource({fileId: \"root\", fields: \"id\"});\r\n        let searchId = folderId;\r\n        for(;;) {\r\n            const file = await Gdfs.getFileResource({\r\n                fileId: searchId,\r\n                fields: \"id, name, parents, mimeType\",\r\n            });\r\n            if(file == null) {\r\n                debug(`folder ${searchId} is not found.`);\r\n                return false;\r\n            }\r\n            if(file.mimeType !== Gdfs.mimeTypeFolder) {\r\n                debug(`folder ${searchId} is not folder.`);\r\n                return false;\r\n            }\r\n            debug(JSON.stringify(file, null,  \"  \"));\r\n            if(file.id == root.id) {\r\n                paths.unshift({id: \"root\", name: \"\" });\r\n                break;\r\n            } else {\r\n                paths.unshift({id: file.id, name: file.name });\r\n            }\r\n            searchId = file.parents.shift();\r\n        }\r\n        debug(JSON.stringify(paths, null, \"  \"));\r\n        this._currentPath = paths;\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * Check the path is a directory.\r\n * @async\r\n * @param {GdfsPath} path A path to check\r\n * @returns {Promise<Boolean>} The path is a directory or not.\r\n */\r\nGdfs.prototype.isDirectory = async function(path) {\r\n    debug(\"No tests pass: Gdfs#isDirectory\");\r\n    const file = await this.getFileOfPath(this.toAbsolutePath(path));\r\n    if(!file) {\r\n        return false;\r\n    }\r\n    return file.mimeType === Gdfs.mimeTypeFolder;\r\n};\r\n\r\n/**\r\n * Convert to absolute path.\r\n * @param {GdfsPath} path path to be converted\r\n * @returns {GdfsPath} An absolute path\r\n */\r\nGdfs.prototype.toAbsolutePath = function(path) {\r\n    debug(\"No tests pass: Gdfs#toAbsolutePath\");\r\n    if(path.isAbsolute()) {\r\n        return path;\r\n    }\r\n    const cwd = this.getCurrentPath();\r\n    return GdfsPath.merge(cwd, path);\r\n};\r\n\r\n/**\r\n * Read the directory to get a list of filenames.\r\n *\r\n * This method may not returns all files in the directory.\r\n * To know all files were listed, check the `pageToken` field in the parameter\r\n * `options` after the invocation.\r\n * If the reading was completed, the field would be set `null`.\r\n * The rest files unread will be returned at the next invocation with same\r\n * parameters.\r\n *\r\n * ```javascript\r\n * const readDirAll = async path => {\r\n *     const opts = { pageSize: 10, pageToken: null };\r\n *     const files = [];\r\n *     do {\r\n *        for(const fn of await files.readdir(opts)) {\r\n *            files.push(fn);\r\n *        }\r\n *     } while(opts.pageToken != null);\r\n * };\r\n * ```\r\n *\r\n * @param {string} path A path to the directory.\r\n *\r\n * @param {object|null} options (Optional) options for this method.\r\n *\r\n * Only two fields are available:\r\n *\r\n * * \"pageSize\": Set maximum array size that this method returns at one\r\n * time.  The default value 10 will be used if this is not specified or\r\n * zero or negative value is specified.\r\n * * \"pageToken\": Set null to initial invocation to read from first\r\n * entry. This would be updated other value if the unread files are\r\n * remained. The value is used for reading next files. User should not\r\n * set the value except for null.\r\n *\r\n * If this parameter is ommited, all files will be read.\r\n * This is not recomended feature for the directory that has a number of files.\r\n *\r\n * @returns {Promise<Array<string> >} returns an array of filenames.\r\n */\r\nGdfs.prototype.readdir = async function(path, options) {\r\n    path += path.match(/\\/$/) ? \"\" : \"/\";\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readdir: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readdir: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n\r\n    if(!Gdfs.isFolder(parentFolder)) {\r\n        debug(`readdir: The path is not a folder ${path}`);\r\n        return null;\r\n    }\r\n\r\n    const files = [];\r\n    const readAll = (options == null);\r\n    options = options || {};\r\n    const pageSize = options.pageSize || 10;\r\n    const pageToken = options.pageToken || null;\r\n\r\n    const readFiles = async params => {\r\n        debug(`readdir: params: ${JSON.stringify(params, null, \"  \")}`);\r\n        const result = await Gdfs.getFileList(params);\r\n        debug(`readdir: result.nextPageToken: ${result.nextPageToken}`);\r\n        for(const file of result.files) {\r\n            files.push(file.name);\r\n        }\r\n        return result.nextPageToken;\r\n    };\r\n\r\n    const params = {\r\n        \"pageSize\": pageSize <= 0 ? 10 : pageSize,\r\n        \"pageToken\": pageToken,\r\n        \"q\": `parents in '${parentFolder.id}' and trashed = false`,\r\n        \"fields\": \"nextPageToken, files(name)\",\r\n    };\r\n\r\n    if(!readAll) {\r\n        options.pageToken = await readFiles(params);\r\n    } else {\r\n        do {\r\n            params.pageToken = await readFiles(params);\r\n        } while(params.pageToken != null);\r\n    }\r\n\r\n    debug(`readdir: files: ${JSON.stringify(files)}`);\r\n    return files;\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {string} path A pathname to get.\r\n * @returns {File} The file resource of Google Drive including id, name,\r\n *      mimeType, webContentLink and webViewLink about the file or directory.\r\n */\r\nGdfs.prototype.stat = async function(path) {\r\n    debug(`Gdfs#stat(${path})`);\r\n    path = path.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(path));\r\n    debug(`stat: absPath: ${absPath.toString()}`);\r\n    path = absPath.toString();\r\n    if(path === \"/\") {\r\n        const file = await Gdfs.getFileResource({\r\n            fileId: \"root\",\r\n            fields: \"id, name, mimeType, webContentLink, webViewLink\",\r\n        });\r\n        debug(`stat: file ${JSON.stringify(file)}`);\r\n        return file;\r\n    }\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`stat: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`stat: The path not exists ${path}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`stat: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    if(files.length === 0) {\r\n        debug(`stat: File not found ${path}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    debug(`stat: file ${JSON.stringify(file)}`);\r\n    return file;\r\n};\r\n\r\n/**\r\n * Read a file.\r\n * @async\r\n * @param {string} pathname A pathname to operate.\r\n * @returns {Promise<string>} The file content.\r\n */\r\nGdfs.prototype.readFile = async function(pathname) {\r\n    debug(`Gdfs#readFile(${pathname})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(pathname));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`readFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`readFile: The path not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`readFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`readFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`File not found ${pathname}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(!file.webContentLink) {\r\n        debug(`File is not downloadable ${pathname}`);\r\n        return null;\r\n    }\r\n    return await Gdfs.downloadFile(file.id);\r\n};\r\n\r\n/**\r\n * Make a directory.\r\n * @async\r\n * @param {string} pathname A pathname to operate.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.mkdir = async function(pathname) {\r\n    debug(`mkdir(${pathname})`);\r\n\r\n    pathname = pathname.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(pathname));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`mkdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`mkdir: The path not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const dirname = absPath.getFilename();\r\n    debug(`mkdir: dirname: ${dirname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, dirname);\r\n    debug(`mkdir: files: ${JSON.stringify(files)}`);\r\n    if(files.length > 0) {\r\n        debug(`mkdir: The directory exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.createFile(\r\n        parentFolder.id, dirname, Gdfs.mimeTypeFolder);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Remove the directory but not a normal file.\r\n * The operation will fail, if it is not a directory nor empty.\r\n * @async\r\n * @param {string} pathname A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.rmdir = async function(pathname) {\r\n    debug(`rmdir(${pathname})`);\r\n    pathname = pathname.replace(/\\/+$/, \"\");\r\n    const absPath = this.toAbsolutePath(new GdfsPath(pathname));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`rmdir: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`rmdir: The path not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const dirname = absPath.getFilename();\r\n    debug(`rmdir: dirname: ${dirname}`);\r\n    if(dirname === \"\") {\r\n        debug(`rmdir: The root directory cannot be removed ${pathname}`);\r\n        return null;\r\n    }\r\n    const dires = await Gdfs.findFolderByName(parentFolder.id, dirname);\r\n    debug(`rmdir: dires: ${JSON.stringify(dires)}`);\r\n    if(dires.length === 0) {\r\n        debug(`rmdir: The directory not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const dir = dires.shift();\r\n    debug(`rmdir: dir ${JSON.stringify(dir)}`);\r\n    debug(`rmdir: _currentPath ${JSON.stringify(this._currentPath, null, \"  \")}`);\r\n    if(this._currentPath.filter(path => path.id == dir.id).length > 0 ||\r\n        dir.id === await Gdfs.getActualRootFolderId())\r\n    {\r\n        debug(`rmdir: The pathname is a parent ${pathname}`);\r\n        return null;\r\n    }\r\n    if(dir.mimeType !== Gdfs.mimeTypeFolder) {\r\n        debug(`rmdir: The pathname is not folder ${pathname}`);\r\n        return null;\r\n    }\r\n    const params = {\r\n        \"q\": `parents in '${dir.id}' and trashed = false`,\r\n        \"fields\": \"files(id)\",\r\n    };\r\n    debug(`rmdir: params ${JSON.stringify(params)}`);\r\n    const children = await Gdfs.getFileList(params);\r\n    debug(`rmdir: children: ${JSON.stringify(children, null, \"  \")}`);\r\n    if(children.files.length > 0) {\r\n        debug(`rmdir: The folder is not empty ${pathname}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete(\r\n        { fileId: dir.id });\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return response.result;\r\n};\r\n\r\n/**\r\n * Delete the file but not directory.\r\n * @async\r\n * @param {string} pathname A pathname to operate.\r\n * @returns {Promise<object|null>} Returns the API response.\r\n *      null means it was failed.\r\n */\r\nGdfs.prototype.unlink = async function(pathname) {\r\n    debug(`unlink(${pathname})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(pathname));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`unlink: parentFolder ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`unlink: The path not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const dirname = absPath.getFilename();\r\n    debug(`unlink: dirname: ${dirname}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, dirname);\r\n    debug(`unlink: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        debug(`unlink: The file not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`unlink: The file is a folder ${pathname}`);\r\n        return null;\r\n    }\r\n    const response = await gapi.client.drive.files.delete({ fileId: file.id });\r\n    const result = response.result;\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Write a file.\r\n * @async\r\n * @param {string} pathname A pathname to operate.\r\n * @param {string} mimeType A mimeType of the file content.\r\n * @param {string} data A file content.\r\n * @returns {Promise<object>} The API response.\r\n */\r\nGdfs.prototype.writeFile = async function(pathname, mimeType, data) {\r\n    debug(`Gdfs#writeFile(${pathname},${mimeType}, ${JSON.stringify(data)})`);\r\n    const absPath = this.toAbsolutePath(new GdfsPath(pathname));\r\n    const parentFolder = await this.getFileOfPath(absPath.getPathPart());\r\n    debug(`writeFile: parentFolder: ${JSON.stringify(parentFolder)}`);\r\n    if(!parentFolder || parentFolder.id == null) {\r\n        debug(`writeFile: The path not exists ${pathname}`);\r\n        return null;\r\n    }\r\n    const filename = absPath.getFilename();\r\n    debug(`writeFile: filename: ${filename}`);\r\n    const files = await Gdfs.findFileByName(parentFolder.id, filename);\r\n    debug(`writeFile: files: ${JSON.stringify(files)}`);\r\n    if(files.length === 0) {\r\n        const file = await Gdfs.createFile(\r\n            parentFolder.id, filename, mimeType);\r\n        const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n        if(parentFolder.id === this.getCurrentFolderId()) {\r\n            await this.fireCwdUpdate();\r\n        }\r\n        return result;\r\n    }\r\n    const file = files.shift();\r\n    if(file.mimeType === Gdfs.mimeTypeFolder) {\r\n        debug(`writeFile: The path already exists as directory ${pathname}`);\r\n        return null;\r\n    }\r\n    const result = await Gdfs.updateFile(file.id, mimeType, data);\r\n    if(parentFolder.id === this.getCurrentFolderId()) {\r\n        await this.fireCwdUpdate();\r\n    }\r\n    return result;\r\n};\r\n\r\nmodule.exports = Gdfs;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdfs-ui\");\r\ndebug(\"loading\");\r\nconst Gdfs = require(\"./gdfs.js\");\r\nconst GdfsEvent = require(\"./gdfs-event.js\");\r\n\r\n/**\r\n * class GdfsUi\r\n * @constructor\r\n * @param {HTMLElement} The root element that UI widget will be built.\r\n * @param {Gdfs} The gapi client.\r\n */\r\nfunction GdfsUi(element, opt) {\r\n    debug(\"Start of GdfsUi ctor\");\r\n    this._element = element;\r\n    this._gdfs = new Gdfs();\r\n    this._pageSize = 10;\r\n    this._trashed = false;\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    this._opt = {\r\n        onFileListChange: () => {},\r\n        onCurrentDirChange: () => {},\r\n    };\r\n\r\n    opt = opt || {};\r\n    for(const key of Object.keys(this._opt)) {\r\n        if(key in opt) {\r\n            this._opt[key] = opt[key];\r\n        }\r\n    }\r\n\r\n    // events\r\n    this._fileListChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-filelist-change\");\r\n    this._currentDirChangeEvent = new GdfsEvent(\r\n        this._element, \"gdfsui-current-dir-change\");\r\n\r\n    this._currentDirChangeEvent.listen(\r\n        this._opt.onCurrentDirChange);\r\n    this._fileListChangeEvent.listen(\r\n        this._opt.onFileListChange);\r\n\r\n    this._gdfs.onCwdUpdate(async () => {\r\n        debug(\"Start of _gdfs.onCwdUpdate\");\r\n        await this.reload();\r\n        this._currentDirChangeEvent.fire();\r\n        debug(\"End of _gdfs.onCwdUpdate\");\r\n    });\r\n\r\n    const onSignedInStatusChange = async status => {\r\n        debug(\"Start of signInStatusChange\");\r\n        if(status) {\r\n            await this._gdfs.chdir(\"/\");\r\n        }\r\n        debug(\"End of signInStatusChange\");\r\n    };\r\n\r\n    // Listen events\r\n    Gdfs.signInStatusChangeEvent.listen(\r\n        () => onSignedInStatusChange(Gdfs.isSignedIn()));\r\n\r\n    onSignedInStatusChange(Gdfs.isSignedIn());\r\n    debug(\"End of GdfsUi ctor\");\r\n}\r\n\r\n/**\r\n * Returns the listing files in current directory is completed.\r\n * @returns {boolean} true if the listing files is completed.\r\n */\r\nGdfsUi.prototype.isPageCompleted = function() {\r\n    const status = this._pageToken == null;\r\n    return status;\r\n};\r\n\r\n/**\r\n * Get current path as full path.\r\n * @returns {Array<string>} The array of file ids.\r\n */\r\nGdfsUi.prototype.getCurrentPath = function() {\r\n    return this._gdfs._currentPath;\r\n};\r\n\r\n/**\r\n * Get files list on current page.\r\n * @param {number} begin a file index\r\n * @param {number} end a file index\r\n * @returns {Array<File>} the files in current page.\r\n */\r\nGdfsUi.prototype.getFiles = async function(begin, end) {\r\n    while(end > this._files.length && this._pageToken != null) {\r\n        await this.readDir();\r\n        this._fileListChangeEvent.fire();\r\n    }\r\n    return this._files.slice(begin, end);\r\n};\r\n\r\n/**\r\n * Read the files on current directory.\r\n * @async\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.readDir = async function() {\r\n\r\n    const andConditionsOfQuerySearchClauses = [\r\n        `parents in '${this._gdfs.getCurrentFolderId()}'`,\r\n        `trashed = ${this._trashed?\"true\":\"false\"}`,\r\n    ];\r\n\r\n    const queryParameters = {\r\n        \"pageSize\": this._pageSize,\r\n        \"pageToken\": this._pageToken,\r\n        \"q\": andConditionsOfQuerySearchClauses.join(\" and \"),\r\n        \"fields\": \"nextPageToken, files(id, name, mimeType, webContentLink, webViewLink)\",\r\n    };\r\n\r\n    const result = await Gdfs.getFileList(queryParameters);\r\n    this._pageToken = result.nextPageToken;\r\n    for(const file of result.files) {\r\n        this._files.push(file);\r\n    }\r\n};\r\n\r\n/**\r\n * Reload the file list.\r\n * @async\r\n * @returns {Promise} to sync\r\n */\r\nGdfsUi.prototype.reload = async function() {\r\n    this._pageToken = null;\r\n    this._files = [];\r\n    await this.readDir();\r\n    this._fileListChangeEvent.fire();\r\n};\r\n\r\n/**\r\n * Move current directory to root, parent or one of children.\r\n * @param {string} folderId A destination file id to move.\r\n * To move to parent, \"..\" is available.\r\n * @returns {Promise<undefined>}\r\n */\r\nGdfsUi.prototype.chdirById = async function(folderId) {\r\n    await this._gdfs.chdirById(folderId);\r\n};\r\n\r\n/**\r\n * Get file resource.\r\n * @async\r\n * @param {string} fileId The file id of the target file.\r\n * @returns {Promise<object>} The resource object.\r\n */\r\nGdfsUi.prototype.getFileResource = async function(fileId) {\r\n    return await Gdfs.getFileResource({\r\n        \"fileId\": fileId,\r\n    });\r\n};\r\n\r\n/**\r\n * Upload a file.\r\n * @param {File} file the file to be uploaded.\r\n * @return {Promise<File>} an uploaded File.\r\n */\r\nGdfsUi.prototype.uploadFile = function (file) {\r\n    return new Promise( (resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n            resolve(await this.writeFile(\r\n                file.name, file.type, reader.result));\r\n        };\r\n        reader.onerror = event => {\r\n            reject(new Error([\r\n                \"Fail to upload. Could not read the file \",\r\n                `${file.name}(${event.type}).`,\r\n            ].join(\"\")));\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n};\r\n\r\n/**\r\n * Create or overwrite a file to current directory.\r\n * @param {string} filename The file name.\r\n * @param {string} mimeType The content type.\r\n * @param {any} data The file content.\r\n * @returns {Promise<object>} The response of update.\r\n */\r\nGdfsUi.prototype.writeFile = async function (\r\n    filename, mimeType, data)\r\n{\r\n    // Find same file in current directory\r\n    const fileIds = this._files\r\n        .filter(file => (file.name === filename))\r\n        .map( file => file.id );\r\n\r\n    if(fileIds.length == 0) {\r\n        //Create new file\r\n        const response = await Gdfs.createFile(\r\n            this._gdfs.getCurrentFolderId(), filename, mimeType);\r\n        const file = JSON.parse(response);\r\n        return await Gdfs.updateFile(\r\n            file.id, mimeType, data);\r\n    }\r\n\r\n    // Overwrite the file\r\n    return await Gdfs.updateFile(\r\n        fileIds[0], mimeType, data);\r\n};\r\n\r\nmodule.exports = GdfsUi;\r\n","\"use strict\";\r\nconst debug = require(\"debug\")(\"gdrive-fs\");\r\nconst Gdfs = require(\"./lib/gdfs.js\");\r\nGdfs.Ui = require(\"./lib/gdfs-ui.js\");\r\nGdfs.Path = require(\"./lib/gdfs-path.js\");\r\ntry {\r\n    const context = (Function(\"return this;\"))();\r\n    if(context === window) {\r\n        window.Gdfs = Gdfs;\r\n    }\r\n} catch(err) {\r\n    debug(err.message);\r\n}\r\nmodule.exports = Gdfs;\r\n"]}